[
  {
    "objectID": "05_select.html",
    "href": "05_select.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nselect_with_ocs\n\n select_with_ocs (population:chewc.structs.Population,\n                  breeding_values:jax.Array, delta_F:float, k:int)\n\nSelects top-k individuals and calculates their optimal contributions.\n\nsource\n\n\nfind_optimal_contributions\n\n find_optimal_contributions (g:jax.Array, A:jax.Array, delta_F:float,\n                             start_lambda:float=1.0,\n                             tolerance:float=1e-06,\n                             max_iterations:int=100)\n\nJIT-compiled function using jax.lax.while_loop to find optimal contributions.\n\nsource\n\n\nselect_top_k\n\n select_top_k (population:chewc.structs.Population, values:jax.Array,\n               k:int)\n\nSelect top-k individuals by values (1-D).",
    "crumbs": [
      "05_select.html"
    ]
  },
  {
    "objectID": "02_structs.html",
    "href": "02_structs.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nBreedingState\n\n BreedingState (population:__main__.Population, key:jax.Array,\n                generation:int, next_id:int)\n\n*The complete, self-contained state of a single simulation replicate at a point in time.\nThis object is the primary carrier passed between steps in the simulation.\nAttributes: population (Population): The current population of individuals. key (jax.Array): The JAX pseudo-random number generator key. generation (int): The current generation number of the simulation.*\n\nsource\n\n\nTrait\n\n Trait (qtl_chromosome:jax.Array, qtl_position:jax.Array,\n        qtl_effects:jax.Array, qtl_dominance_effects:jax.Array,\n        intercept:jax.Array)\n\n*Defines the genetic architecture of one or more traits.\nThis structure holds the information linking genotypes to phenotypes, based on an additive and dominance QTL model.\nAttributes: qtl_chromosome (jnp.ndarray): Chromosome index for each QTL. Shape: (n_qtl,) qtl_position (jnp.ndarray): Locus index for each QTL within its chromosome. Shape: (n_qtl,) qtl_effects (jnp.ndarray): The additive effect of each QTL on each trait. Shape: (n_qtl, n_traits) qtl_dominance_effects (jnp.ndarray): The dominance effect of each QTL on each trait. Shape: (n_qtl, n_traits) intercept (jnp.ndarray): The base value for each trait. Shape: (n_traits,)*\n\nsource\n\n\nPopulation\n\n Population (geno:jax.Array, ibd:jax.Array, meta:jax.Array)\n\n*Represents a collection of individuals within a breeding program.\nAttributes: geno (jnp.ndarray): Genotypes. Shape: (n_individuals, n_chr, 2, n_loci) ibd (jnp.ndarray): Identity-by-descent tracking for founder alleles. Shape: (n_individuals, n_chr, 2, n_loci) meta (jnp.ndarray): Metadata [id, mother_id, father_id, birth_gen]. Shape: (n_individuals, 4)*\n\nsource\n\n\nGeneticMap\n\n GeneticMap (chromosome_lengths:jax.Array,\n             locus_positions:List[jax.Array])\n\n*Defines the genetic map of the organism.\nAttributes: chromosome_lengths (jnp.ndarray): The genetic length of each chromosome in Morgans. Shape: (n_chr,) locus_positions (List[jnp.ndarray]): A list where each element is a JAX array containing the Morgan positions of loci for a single chromosome.*\n\nsource\n\n\nmsprime_pop\n\n msprime_pop (key:jax.Array, n_ind:int, n_chr:int, n_loci_per_chr:int,\n              ploidy:int=2, effective_population_size:int=5000,\n              mutation_rate:float=1e-07,\n              recombination_rate_per_chr:float=1e-08,\n              maf_threshold:float=0.05, base_chr_length:int=500000,\n              num_simulated_individuals:Optional[int]=None,\n              enforce_founder_maf:bool=True)\n\n*Simulate a padded founder population from an msprime ancestry model.\nThe output matches the lightweight Population/GeneticMap structures used by the workflow notebooks so it can plug straight into trait sampling, phenotype simulation, and selection routines.*\n\nsource\n\n\nquick_haplo\n\n quick_haplo (key:jax.Array, n_ind:int, n_chr:int, seg_sites:int,\n              inbred:bool=False, chr_length:float=1.0)\n\nCreate a simple founder population and a uniform genetic map.\n\nsource\n\n\nadd_trait\n\n add_trait (key:jax.Array, founder_pop:chewc.structs.Population,\n            n_qtl_per_chr:int, mean:jax.Array, var_a:jax.Array,\n            var_d:jax.Array, sigma:jax.Array)\n\nSample QTLs and multi-trait effects for both additive and dominance components.\n\n\n\n\nType\nDetails\n\n\n\n\nkey\nArray\n\n\n\nfounder_pop\nPopulation\n\n\n\nn_qtl_per_chr\nint\n\n\n\nmean\nArray\n(n_traits,)\n\n\nvar_a\nArray\nAdditive variance (n_traits,)\n\n\nvar_d\nArray\nDominance variance (n_traits,)\n\n\nsigma\nArray\n(n_traits, n_traits) PSD\n\n\nReturns\nTrait\n\n\n\n\n\nsource\n\n\ncompute_dosage\n\n compute_dosage (population:chewc.structs.Population)\n\n*Computes the dosage of the ‘1’ allele for each individual at each locus.\nDosage is calculated as the sum of alleles across the two homologous chromosomes, resulting in values of 0, 1, or 2.\nArgs: population: A Population object.\nReturns: A 3D array of dosages with shape (n_individuals, n_chr, n_loci).*\n\nkey = jax.random.PRNGKey(42)\nfounder_pop = quick_haplo(\nkey=key,\nn_ind=10,\nn_chr=3,\nseg_sites=100,\ninbred=False\n )\n\nWARNING:2025-10-04 20:20:06,008:jax._src.xla_bridge:794: An NVIDIA GPU may be present on this machine, but a CUDA-enabled jaxlib is not installed. Falling back to cpu.",
    "crumbs": [
      "02_structs.html"
    ]
  },
  {
    "objectID": "04_phenotype.html",
    "href": "04_phenotype.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\ncalculate_phenotypes\n\n calculate_phenotypes (key:jax.Array, population:chewc.structs.Population,\n                       trait:chewc.structs.Trait, heritability:jax.Array)\n\nReturn (phenotypes, true_breeding_values). Calculates phenotypes by modeling G = A + D.\n\n\n\n\nType\nDetails\n\n\n\n\nkey\nArray\n\n\n\npopulation\nPopulation\n\n\n\ntrait\nTrait\n\n\n\nheritability\nArray\nNarrow-sense h^2, shape: (n_traits,)\n\n\nReturns\nTuple\n\n\n\n\n\nsource\n\n\ncompute_dosage\n\n compute_dosage (population:chewc.structs.Population)\n\nComputes allele dosage. Shape: (n_ind, n_chr, n_loci)",
    "crumbs": [
      "04_phenotype.html"
    ]
  },
  {
    "objectID": "06_cross.html",
    "href": "06_cross.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\ncreate_ocs_mating_plan\n\n create_ocs_mating_plan (key:jax.Array, candidate_ids:jax.Array,\n                         contributions:jax.Array, n_crosses:int,\n                         allow_selfing:bool=False)\n\nGenerates a mating list based on optimal contribution scores for unisex populations.\n\nsource\n\n\ncross_pair\n\n cross_pair (key:jax.Array, mother_geno:jax.Array, father_geno:jax.Array,\n             mother_ibd:jax.Array, father_ibd:jax.Array,\n             genetic_map:chewc.structs.GeneticMap, max_crossovers:int)\n\n\n\n\n\nType\nDetails\n\n\n\n\nkey\nArray\n\n\n\nmother_geno\nArray\n\n\n\nfather_geno\nArray\n(n_chr, 2, n_loci)\n\n\nmother_ibd\nArray\n\n\n\nfather_ibd\nArray\n(n_chr, 2, n_loci)\n\n\ngenetic_map\nGeneticMap\n\n\n\nmax_crossovers\nint\n\n\n\nReturns\nTuple\n\n\n\n\n\nsource\n\n\nrandom_mating\n\n random_mating (key:jax.Array, n_parents:int, n_crosses:int)\n\nSample (mother, father) pairs with replacement. Works even when n_parents is not a Python literal.",
    "crumbs": [
      "06_cross.html"
    ]
  },
  {
    "objectID": "03_meiosis.html",
    "href": "03_meiosis.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\ncreate_gamete\n\n create_gamete (key:jax.Array, parent_geno:jax.Array,\n                parent_ibd:jax.Array,\n                genetic_map:chewc.structs.GeneticMap,\n                interference_nu:float, max_crossovers:int)\n\nReturn a haploid gamete (geno, ibd) of shape (n_chr, n_loci).\n\n\n\n\nType\nDetails\n\n\n\n\nkey\nArray\n\n\n\nparent_geno\nArray\n(n_chr, 2, n_loci)\n\n\nparent_ibd\nArray\n(n_chr, 2, n_loci)\n\n\ngenetic_map\nGeneticMap\n\n\n\ninterference_nu\nfloat\n\n\n\nmax_crossovers\nint\n\n\n\nReturns\nTuple",
    "crumbs": [
      "03_meiosis.html"
    ]
  },
  {
    "objectID": "000_wf.html",
    "href": "000_wf.html",
    "title": "chewc",
    "section": "",
    "text": "import jax\nimport jax.numpy as jnp\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom IPython.display import display\n\nfrom chewc.gym import StoaEnv\nfrom chewc.pheno import calculate_phenotypes\n\nplt.style.use('tableau-colorblind10')\n\n\ndef run_constant_action_episode(env: StoaEnv, action_value: float, rng_key: jax.Array):\n    params = env.default_params\n    reset_key, rng_key = jax.random.split(rng_key)\n    _, state = env.reset_env(reset_key, params)\n\n    action = jnp.array([action_value], dtype=jnp.float32)\n    final_reward = 0.0\n\n    while True:\n        rng_key, step_key = jax.random.split(rng_key)\n        _, state, reward, done, _ = env.step_env(step_key, state, action, params)\n        final_reward = float(reward)\n        if bool(done):\n            break\n\n    phenokey, _ = jax.random.split(state.key)\n    phenotypes, tbv = calculate_phenotypes(\n        phenokey,\n        population=state.population,\n        trait=env.trait_architecture,\n        heritability=env.heritabilities,\n    )\n\n    phenotypes = np.asarray(phenotypes[:, 0])\n    tbv = np.asarray(tbv[:, 0])\n    return final_reward, float(phenotypes.mean()), float(tbv.mean())\n\n\ndef evaluate_constant_actions(\n    env: StoaEnv,\n    action_values,\n    num_episodes: int = 32,\n    seed: int = 0,\n) -&gt; pd.DataFrame:\n    rng = jax.random.PRNGKey(seed)\n    records = []\n\n    for action in action_values:\n        rewards = []\n        phenotype_means = []\n        tbv_means = []\n\n        for _ in range(num_episodes):\n            rng, episode_key = jax.random.split(rng)\n            reward, phenotype_mean, tbv_mean = run_constant_action_episode(\n                env, action, episode_key\n            )\n            rewards.append(reward)\n            phenotype_means.append(phenotype_mean)\n            tbv_means.append(tbv_mean)\n\n        records.append(\n            {\n                'action': float(action),\n                'reward_mean': float(np.mean(rewards)),\n                'reward_std': float(np.std(rewards, ddof=1)) if num_episodes &gt; 1 else 0.0,\n                'phenotype_mean': float(np.mean(phenotype_means)),\n                'phenotype_std': float(np.std(phenotype_means, ddof=1)) if num_episodes &gt; 1 else 0.0,\n                'tbv_mean': float(np.mean(tbv_means)),\n                'tbv_std': float(np.std(tbv_means, ddof=1)) if num_episodes &gt; 1 else 0.0,\n            }\n        )\n\n    return pd.DataFrame.from_records(records)\n\ngym = StoaEnv(total_gen=5)\n\nbaseline_actions = [-1.0, -0.5]\nbaseline_df = evaluate_constant_actions(gym, baseline_actions, num_episodes=5, seed=0)\ndisplay(baseline_df)\n\nfig, axes = plt.subplots(1, 3, figsize=(12, 4), sharex=True)\nmetrics = [\n    ('reward_mean', 'Reward'),\n    ('phenotype_mean', 'Phenotype Mean'),\n    ('tbv_mean', 'TBV Mean'),\n]\n\nfor ax, (column, title) in zip(axes, metrics):\n    ax.bar(baseline_df['action'], baseline_df[column], color='#4c72b0')\n    ax.set_title(title)\n    ax.set_xlabel('Action value')\n    ax.set_xticks(baseline_df['action'])\n    ax.set_ylabel(title)\n    ax.grid(axis='y', alpha=0.2, linestyle='--', linewidth=0.7)\n\nfig.suptitle('Constant Action Bas')\ndef run_constant_action_episode(env: StoaEnv, action_value: float, rng_key: jax.Array):\n    \"\"\"Runs a single episode with a constant action and tracks step-wise data.\"\"\"\n    params = env.default_params\n    reset_key, rng_key = jax.random.split(rng_key)\n    _, state = env.reset_env(reset_key, params)\n\n    action = jnp.array([action_value], dtype=jnp.float32)\n\n    # Lists to store step-wise data\n    step_rewards = []\n    step_phenotype_means = []\n    step_tbv_means = []\n    step_actions = [] # Store action at each step\n    steps = []       # Store step number\n\n    current_step = 0\n    while True:\n        rng_key, step_key = jax.random.split(rng_key)\n        phenokey, rng_key = jax.random.split(rng_key) # Need a key for phenotype calculation each step\n\n        # Calculate metrics *before* taking the step to align with step number\n        current_phenotypes, current_tbv = calculate_phenotypes(\n            phenokey,\n            population=state.population,\n            trait=env.trait_architecture,\n            heritability=env.heritabilities,\n        )\n        step_phenotype_means.append(float(jnp.asarray(current_phenotypes[:, 0]).mean()))\n        step_tbv_means.append(float(jnp.asarray(current_tbv[:, 0]).mean()))\n        step_actions.append(action_value) # Store the constant action\n        steps.append(current_step)\n\n        # Environment step\n        _, state, reward, done, _ = env.step_env(step_key, state, action, params)\n        step_rewards.append(float(reward)) # Store reward received *after* the step\n\n        current_step += 1\n\n        if bool(done):\n            # Record final state metrics if needed (or adjust logic based on when metrics should reflect state)\n            # For simplicity here, we stop after the 'done' flag is True\n            break\n\n    # Final metrics calculation (optional, depending on what 'final_reward' represents)\n    # phenokey_final, _ = jax.random.split(state.key)\n    # phenotypes_final, tbv_final = calculate_phenotypes(\n    #     phenokey_final,\n    #     population=state.population,\n    #     trait=env.trait_architecture,\n    #     heritability=env.heritabilities,\n    # )\n    # final_phenotype_mean = float(jnp.asarray(phenotypes_final[:, 0]).mean())\n    # final_tbv_mean = float(jnp.asarray(tbv_final[:, 0]).mean())\n    final_reward = step_rewards[-1] # Example: use the last reward\n\n    # Return step-wise data along with final metrics\n    step_data = pd.DataFrame({\n        'step': steps,\n        'action': step_actions,\n        'reward': step_rewards, # Note: reward list might be one shorter if not recorded after final step before break\n        'phenotype_mean': step_phenotype_means,\n        'tbv_mean': step_tbv_means\n    })\n\n    # Adjust reward list length if necessary\n    if len(step_rewards) &lt; len(steps):\n         step_data = step_data.iloc[:-1].copy() # Drop last row if reward list is shorter\n         step_data['reward'] = step_rewards\n\n\n    return final_reward, step_data # Return final reward and the DataFrame of step data\n\n\ndef evaluate_constant_actions(\n    env: StoaEnv,\n    action_values,\n    num_episodes: int = 32,\n    seed: int = 0,\n) -&gt; pd.DataFrame:\n    \"\"\"Evaluates constant actions, collecting step-wise data for the first episode of each action.\"\"\"\n    rng = jax.random.PRNGKey(seed)\n    # records = [] # Keeping this if you still want summary stats\n    all_step_data = [] # List to store step data DataFrames\n\n    for action in action_values:\n        rewards = []\n        # phenotype_means = [] # For summary stats if needed\n        # tbv_means = [] # For summary stats if needed\n        first_episode_step_data = None\n\n        for i in range(num_episodes):\n            rng, episode_key = jax.random.split(rng)\n            final_reward, step_data = run_constant_action_episode(\n                env, action, episode_key\n            )\n            rewards.append(final_reward)\n            # phenotype_means.append(step_data['phenotype_mean'].iloc[-1]) # Example: final phenotype mean\n            # tbv_means.append(step_data['tbv_mean'].iloc[-1]) # Example: final tbv mean\n\n            if i == 0: # Store step data only for the first episode\n                step_data['action_value'] = float(action) # Add action value column for grouping/labeling\n                step_data['episode'] = i # Add episode identifier\n                first_episode_step_data = step_data\n\n        all_step_data.append(first_episode_step_data)\n\n        # If you still need the summary DataFrame, uncomment and adjust this part\n        # records.append(\n        #     {\n        #         'action': float(action),\n        #         'reward_mean': float(np.mean(rewards)),\n        #         'reward_std': float(np.std(rewards, ddof=1)) if num_episodes &gt; 1 else 0.0,\n        #         'phenotype_mean': float(np.mean(phenotype_means)),\n        #         'phenotype_std': float(np.std(phenotype_means, ddof=1)) if num_episodes &gt; 1 else 0.0,\n        #         'tbv_mean': float(np.mean(tbv_means)),\n        #         'tbv_std': float(np.std(tbv_means, ddof=1)) if num_episodes &gt; 1 else 0.0,\n        #     }\n        # )\n\n    # Concatenate step data from the first episode of each action\n    combined_step_data = pd.concat(all_step_data, ignore_index=True)\n\n    # return pd.DataFrame.from_records(records) # Return summary if needed\n    return combined_step_data\n\n\n# --- Simulation & Plotting ---\ngym = StoaEnv(total_gen=10) # Increase generations for a longer plot\n\nbaseline_actions = [-1.0, -0.5, 0.0, 0.5, 1.0] # Evaluate more actions\nstep_wise_df = evaluate_constant_actions(gym, baseline_actions, num_episodes=5, seed=0) # Run simulation\n\n# --- New Plotting Logic ---\nfig, axes = plt.subplots(2, 2, figsize=(12, 8), sharex=True) # Changed to 2x2 grid\naxes = axes.flatten() # Flatten axes array for easy iteration\n\nmetrics_to_plot = [\n    ('action', 'Action Taken'),\n    ('reward', 'Step Reward'),\n    ('phenotype_mean', 'Phenotype Mean'),\n    ('tbv_mean', 'TBV Mean'),\n]\n\n# Group data by the constant action value used for the episode\ngrouped_data = step_wise_df.groupby('action_value')\n\n# Define colors (optional, but helps distinguish lines)\ncolors = plt.cm.viridis(np.linspace(0, 1, len(baseline_actions)))\n\nfor ax, (column, title) in zip(axes, metrics_to_plot):\n    for i, (action_val, group) in enumerate(grouped_data):\n        ax.plot(group['step'], group[column], marker='o', linestyle='-', label=f'Action={action_val}', color=colors[i], markersize=4, alpha=0.8)\n    ax.set_title(title)\n    ax.set_xlabel('Step in Episode')\n    ax.set_ylabel(title)\n    ax.grid(axis='y', alpha=0.3, linestyle='--', linewidth=0.7)\n    if column == 'action': # Keep legend only on the first plot for clarity\n         ax.legend(title=\"Constant Action\", bbox_to_anchor=(1.05, 1), loc='upper left')\n    #else:\n    #     ax.legend().set_visible(False)\n\n\n# Remove legend from other plots if created automatically and adjust layout\n# for ax in axes[1:]:\n#      if ax.get_legend():\n#           ax.get_legend().remove()\n\nfig.suptitle('Step-wise Performance during First Episode for Constant Actions')\nfig.tight_layout(rect=[0, 0.03, 0.85, 0.95]) # Adjust layout to make space for legend outside\n\nplt.show()\n\n# Display the collected step-wise data\nprint(\"\\nStep-wise data for the first episode of each action:\")\ndisplay(step_wise_df)eline Performance')\nfig.tight_layout(rect=[0, 0.03, 1, 0.95])\nfig\n\n\n  Cell In[10], line 276\n    display(step_wise_df)eline Performance')\n                                          ^\nSyntaxError: unterminated string literal (detected at line 276)\n\n\n\n\n\nThe Kernel crashed while executing code in the current cell or a previous cell. \n\nPlease review the code in the cell(s) to identify a possible cause of the failure. \n\nClick &lt;a href='https://aka.ms/vscodeJupyterKernelCrash'&gt;here&lt;/a&gt; for more info. \n\nView Jupyter &lt;a href='command:jupyter.viewOutput'&gt;log&lt;/a&gt; for further details.",
    "crumbs": [
      "000_wf.html"
    ]
  },
  {
    "objectID": "08_wrappers.html",
    "href": "08_wrappers.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nNormalizeVecReward\n\n NormalizeVecReward (env, gamma)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nNormalizeVecRewEnvState\n\n NormalizeVecRewEnvState (mean:jax.Array, var:jax.Array, count:float,\n                          return_val:float, env_state:gymnax.environments.\n                          environment.EnvState)\n\n\nsource\n\n\nNormalizeVecObservation\n\n NormalizeVecObservation (env)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nNormalizeVecObsEnvState\n\n NormalizeVecObsEnvState (mean:jax.Array, var:jax.Array, count:float,\n                          env_state:gymnax.environments.environment.EnvSta\n                          te)\n\n\nsource\n\n\nVecEnv\n\n VecEnv (env)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nTransformReward\n\n TransformReward (env, transform_reward)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nTransformObservation\n\n TransformObservation (env, transform_obs)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nClipAction\n\n ClipAction (env, low=-1.0, high=1.0)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nNavixGymnaxWrapper\n\n NavixGymnaxWrapper (env_name)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nBraxGymnaxWrapper\n\n BraxGymnaxWrapper (env_name, backend='positional')\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nLogWrapper\n\n LogWrapper (env:gymnax.environments.environment.Environment)\n\nLog the episode returns and lengths.\n\nsource\n\n\nLogEnvState\n\n LogEnvState (env_state:gymnax.environments.environment.EnvState,\n              episode_returns:float, episode_lengths:int,\n              returned_episode_returns:float,\n              returned_episode_lengths:int, timestep:int)\n\n\nsource\n\n\nFlattenObservationWrapper\n\n FlattenObservationWrapper\n                            (env:gymnax.environments.environment.Environme\n                            nt)\n\nFlatten the observations of the environment.\n\nsource\n\n\nGymnaxWrapper\n\n GymnaxWrapper (env)\n\nBase class for Gymnax wrappers.",
    "crumbs": [
      "08_wrappers.html"
    ]
  },
  {
    "objectID": "09_gym.html",
    "href": "09_gym.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nStoaEnv\n\n StoaEnv (n_founders=100, n_pop_size=200, n_chr=5, n_loci=1000,\n          n_qtl_per_chr=50, total_gen=20, max_crossovers=10)\n\n*A Gymnax environment for the ChewC breeding simulation.\nThe agent’s goal is to maximize the genetic gain of the population over a fixed number of generations by choosing the selection intensity at each step.*\n\n\n\nevaluate_constant_actions\n\n evaluate_constant_actions (env:__main__.StoaEnv, action_values,\n                            num_episodes:int=32, seed:int=0,\n                            confidence_level:float=0.95)\n\nEvaluates constant actions over multiple episodes.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nenv\nStoaEnv\n\n\n\n\naction_values\n\n\n\n\n\nnum_episodes\nint\n32\n\n\n\nseed\nint\n0\n\n\n\nconfidence_level\nfloat\n0.95\nFor confidence interval\n\n\nReturns\nDataFrame\n\n\n\n\n\n\n\n\nrun_constant_action_episode\n\n run_constant_action_episode (env:__main__.StoaEnv, action_value:float,\n                              rng_key:jax.Array)\n\nRuns a single episode with a constant action and returns metrics and history.\n\nsource\n\n\nStoaEnv\n\n StoaEnv (n_founders=100, n_pop_size=200, n_chr=5, n_loci=1000,\n          n_qtl_per_chr=50, total_gen=20, max_crossovers=10)\n\n*A Gymnax environment for the ChewC breeding simulation.\nThe agent’s goal is to maximize the genetic gain of the population over a fixed number of generations by choosing the selection intensity at each step.*",
    "crumbs": [
      "09_gym.html"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "chewc",
    "section": "",
    "text": "If you are new to using nbdev here are some useful pointers to get you started.\n\n\n# make sure chewc package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to chewc\n$ nbdev_prepare",
    "crumbs": [
      "chewc"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "chewc",
    "section": "",
    "text": "If you are new to using nbdev here are some useful pointers to get you started.\n\n\n# make sure chewc package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to chewc\n$ nbdev_prepare",
    "crumbs": [
      "chewc"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "chewc",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/cjGO/chewc.git\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages.\n\n\nMulti trait simulation example\nThis code block sets up the simulation parameters, creates a founder population in linkage equilbrium across loci, and simulates 2 correlated traits.\nThen a single generation is simulated from the founder population and ABLUP and GBLUP models are fitted for the offspring.\nBoth the breeding simulation and prediction models are running on JAX.",
    "crumbs": [
      "chewc"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "chewc",
    "section": "How to use",
    "text": "How to use\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom functools import partial\nfrom typing import Tuple\nfrom scipy.sparse import coo_matrix\n\n# JAX's iterative solver and sparse matrix format\nfrom jax.scipy.sparse.linalg import cg\nimport jax.experimental.sparse as jsparse\n\n# Assume the 'chewc' library is installed\nfrom chewc.structs import (\n    Population,\n    Trait,\n    GeneticMap,\n    quick_haplo,\n    add_trait\n)\nfrom chewc.pheno import calculate_phenotypes\nfrom chewc.select import select_top_k\nfrom chewc.cross import random_mating, cross_pair\nfrom chewc.blup import *\n\n\nif __name__ == \"__main__\":\n    # --- Parameters ---\n    N_FOUNDERS, N_SELECT, N_OFFSPRING = 200, 20, 200\n    N_CHR, N_LOCI = 5, 1000\n    SEED = 42\n    N_TRAITS = 2\n    h2_trait1, h2_trait2 = 0.5, 0.5\n    genetic_corr = 0.5\n    \n    # --- Setup (Co)variance matrices ---\n    var_g1, var_g2 = h2_trait1, h2_trait2\n    cov_g12 = genetic_corr * jnp.sqrt(var_g1 * var_g2)\n    G0 = jnp.array([[var_g1, cov_g12], [cov_g12, var_g2]])\n    \n    var_e1, var_e2 = 1 - h2_trait1, 1 - h2_trait2\n    R0 = jnp.diag(jnp.array([var_e1, var_e2]))\n    \n    G0_inv, R0_inv = jnp.linalg.inv(G0), jnp.linalg.inv(R0)\n\n    # --- Population Simulation ---\n    print(\"--- Step 1-4: Simulating population and multi-trait phenotypes ---\")\n    key = jax.random.PRNGKey(SEED)\n    key, pop_key, trait_key, pheno_key, mating_key, cross_key = jax.random.split(key, 6)\n    \n    founder_pop, genetic_map = quick_haplo(key=pop_key, n_ind=N_FOUNDERS, n_chr=N_CHR, seg_sites=N_LOCI)\n    \n    trait_architecture = add_trait(\n        key=trait_key, founder_pop=founder_pop, n_qtl_per_chr=50,\n        mean=jnp.array([100.0, 50.0]), var_a=jnp.array([var_g1, var_g2]), var_d=jnp.array([0.0, 3.0]), sigma=G0\n    )\n    \n    founder_phenotypes, founder_tbvs = calculate_phenotypes(\n        key=pheno_key, population=founder_pop, trait=trait_architecture,\n        heritability=jnp.array([h2_trait1, h2_trait2])\n    )\n    \n    selected_parents = select_top_k(founder_pop, founder_phenotypes[:, 0], k=N_SELECT)\n    pairings = random_mating(mating_key, n_parents=N_SELECT, n_crosses=N_OFFSPRING)\n    \n    vmapped_cross = jax.vmap(cross_pair, in_axes=(0, 0, 0, 0, 0, None, None))\n    offspring_keys = jax.random.split(cross_key, N_OFFSPRING)\n    offspring_geno, offspring_ibd = vmapped_cross(\n        offspring_keys, selected_parents.geno[pairings[:, 0]], selected_parents.geno[pairings[:, 1]],\n        selected_parents.ibd[pairings[:, 0]], selected_parents.ibd[pairings[:, 1]],\n        genetic_map, 10\n    )\n    \n    new_meta = jnp.stack([\n        jnp.arange(N_OFFSPRING) + N_FOUNDERS,\n        selected_parents.meta[pairings[:, 0], 0],\n        selected_parents.meta[pairings[:, 1], 0],\n        jnp.full((N_OFFSPRING,), 1),\n    ], axis=-1)\n    offspring_pop = Population(geno=offspring_geno, ibd=offspring_ibd, meta=new_meta)\n    \n    key, offspring_pheno_key = jax.random.split(key)\n    offspring_phenotypes, offspring_tbvs = calculate_phenotypes(\n        key=offspring_pheno_key, population=offspring_pop, trait=trait_architecture,\n        heritability=jnp.array([h2_trait1, h2_trait2])\n    )\n    \n    all_phenotypes = jnp.concatenate([founder_phenotypes, offspring_phenotypes], axis=0)\n    print(\"--- Population simulation complete ---\")\n\n    # --- ABLUP (Sparse, Iterative) ---\n    print(\"\\n--- Performing Multi-Trait ABLUP (Sparse Iterative) ---\")\n    full_pedigree = jnp.concatenate([founder_pop.meta, offspring_pop.meta], axis=0)\n    remapped_ped_np = remap_pedigree(full_pedigree)\n    \n    A_inv_sparse = build_a_inverse_sparse(remapped_ped_np)\n    ablup_ebvs = solve_multi_trait_mme_iterative(\n        all_phenotypes, A_inv_sparse, G0_inv, R0_inv, n_traits=N_TRAITS\n    )\n    print(\"ABLUP calculation complete.\")\n    \n    # --- GBLUP (Iterative) ---\n    print(\"\\n--- Performing Multi-Trait GBLUP (Iterative) ---\")\n    all_geno = jnp.concatenate([founder_pop.geno, offspring_pop.geno], axis=0)\n    G_matrix = build_g_matrix(all_geno)\n    G_inv = jnp.linalg.inv(G_matrix + jnp.identity(G_matrix.shape[0]) * 1e-4)\n    \n    gblup_gebvs = solve_multi_trait_mme_iterative(\n        all_phenotypes, G_inv, G0_inv, R0_inv, n_traits=N_TRAITS\n    )\n    print(\"GBLUP calculation complete.\")\n\n    # --- Compare Results ---\n    print(\"\\n--- Comparison of Results for Offspring ---\")\n    offspring_ablup = ablup_ebvs[N_FOUNDERS:]\n    offspring_gblup = gblup_gebvs[N_FOUNDERS:]\n\n    acc_ablup_t1 = jnp.corrcoef(offspring_tbvs[:, 0], offspring_ablup[:, 0])[0, 1]\n    acc_ablup_t2 = jnp.corrcoef(offspring_tbvs[:, 1], offspring_ablup[:, 1])[0, 1]\n    acc_gblup_t1 = jnp.corrcoef(offspring_tbvs[:, 0], offspring_gblup[:, 0])[0, 1]\n    acc_gblup_t2 = jnp.corrcoef(offspring_tbvs[:, 1], offspring_gblup[:, 1])[0, 1]\n\n    print(f\"\\nABLUP Accuracy -&gt; Trait 1: {acc_ablup_t1:.4f}, Trait 2: {acc_ablup_t2:.4f}\")\n    print(f\"GBLUP Accuracy -&gt; Trait 1: {acc_gblup_t1:.4f}, Trait 2: {acc_gblup_t2:.4f}\")\n    print('Note: both traits have the same heritabilities; but trait 2 has strong dominance effects, lowering accuracy')\n\n    print(\"\\n{:&lt;6} | {:&gt;12} {:&gt;12} | {:&gt;12} {:&gt;12} | {:&gt;12} {:&gt;12}\".format(\n        \"ID\", \"TBV T1\", \"TBV T2\", \"ABLUP T1\", \"ABLUP T2\", \"GBLUP T1\", \"GBLUP T2\"))\n    print(\"-\" * 88)\n    for i in range(10):\n        print(\"{:&lt;6} | {:&gt;12.3f} {:&gt;12.3f} | {:&gt;12.3f} {:&gt;12.3f} | {:&gt;12.3f} {:&gt;12.3f}\".format(\n            int(offspring_pop.meta[i, 0]),\n            offspring_tbvs[i, 0], offspring_tbvs[i, 1],\n            offspring_ablup[i, 0], offspring_ablup[i, 1],\n            offspring_gblup[i, 0], offspring_gblup[i, 1]\n        ))\n\n--- Step 1-4: Simulating population and multi-trait phenotypes ---\n--- Population simulation complete ---\n\n--- Performing Multi-Trait ABLUP (Sparse Iterative) ---\n[DEBUG] Sparse A_inv successfully created with 1406 non-zero elements.\n[DEBUG] First 5 data points of A_inv: [1. 1. 1. 1. 1.]\nABLUP calculation complete.\n\n--- Performing Multi-Trait GBLUP (Iterative) ---\nGBLUP calculation complete.\n\n--- Comparison of Results for Offspring ---\n\nABLUP Accuracy -&gt; Trait 1: 0.7611, Trait 2: 0.5660\nGBLUP Accuracy -&gt; Trait 1: 0.8045, Trait 2: 0.5809\nNote: both traits have the same heritabilities; but trait 2 has strong dominance effects, lowering accuracy\n\nID     |       TBV T1       TBV T2 |     ABLUP T1     ABLUP T2 |     GBLUP T1     GBLUP T2\n----------------------------------------------------------------------------------------\n200    |        0.847        1.461 |        0.322        1.116 |       -0.352        0.364\n201    |        1.682        2.124 |        0.722        0.735 |        0.215        0.453\n202    |        2.488        1.058 |        1.688        1.321 |        1.163        1.017\n203    |        2.594        1.706 |        0.780       -0.772 |        0.553       -1.136\n204    |        2.269        0.813 |        1.850        1.366 |        1.186        1.020\n205    |        2.632        1.291 |        1.492        1.700 |        0.939        0.960\n206    |        2.682        2.317 |        1.919        2.742 |        1.315        2.362\n207    |        3.482        2.645 |        2.379        3.829 |        1.891        3.462\n208    |        1.728        1.467 |        0.913        0.271 |        0.322       -0.260\n209    |        2.602        2.125 |        0.888        0.409 |        0.511        0.211",
    "crumbs": [
      "chewc"
    ]
  },
  {
    "objectID": "07_blup.html",
    "href": "07_blup.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nremap_pedigree\n\n remap_pedigree (full_pedigree:jax.Array)\n\nRemaps IDs and returns a NumPy array for the sparse builder.\n\nsource\n\n\nsolve_multi_trait_mme_iterative\n\n solve_multi_trait_mme_iterative (y:jax.Array,\n                                  relationship_matrix_inv:jax.experimental\n                                  .sparse.bcoo.BCOO, G0_inv:jax.Array,\n                                  R0_inv:jax.Array, n_traits:int)\n\nSolves a multi-trait MME using an iterative Conjugate Gradient solver.\n\nsource\n\n\nbuild_g_matrix\n\n build_g_matrix (geno:jax.Array)\n\nConstructs the Genomic Relationship Matrix (G).\n\nsource\n\n\nbuild_a_inverse_sparse\n\n build_a_inverse_sparse (pedigree_meta:numpy.ndarray)\n\nConstructs the inverse of the Numerator Relationship Matrix (A_inv) directly from a pedigree using the correct, numerically stable version of Henderson’s rules. Returns the matrix in JAX’s BCOO sparse format.",
    "crumbs": [
      "07_blup.html"
    ]
  },
  {
    "objectID": "wf2.html",
    "href": "wf2.html",
    "title": "Wright–Fisher v2 Setup",
    "section": "",
    "text": "We will: - simulate a founder population with msprime_pop to get realistic haplotypes and a genetic map. - sample an additive-only trait architecture scaled to a target additive variance. - draw noisy phenotypes at a chosen heritability so the pipeline is ready for downstream selection experiments.\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom numpy.random import default_rng\nimport msprime\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom typing import Optional, Tuple\nfrom IPython.display import display\n\nfrom chewc.structs import Population, GeneticMap, add_trait\nfrom chewc.pheno import calculate_phenotypes\n\nplt.style.use('seaborn-v0_8')\n\n/home/glect/.local/lib/python3.10/site-packages/matplotlib/projections/__init__.py:63: UserWarning: Unable to import Axes3D. This may be due to multiple versions of Matplotlib being installed (e.g. as a system package and as a pip package). As a result, the 3D projection is not available.\n  warnings.warn(\"Unable to import Axes3D. This may be due to multiple versions of \"\n\n\n\nsource\n\nmsprime_pop\n\n msprime_pop (key:jax.Array, n_ind:int, n_chr:int, n_loci_per_chr:int,\n              ploidy:int=2, effective_population_size:int=5000,\n              mutation_rate:float=1e-07,\n              recombination_rate_per_chr:float=1e-08,\n              maf_threshold:float=0.05, base_chr_length:int=500000,\n              num_simulated_individuals:Optional[int]=None,\n              enforce_founder_maf:bool=True)\n\n*Simulate a padded founder population from an msprime ancestry model.\nThe output matches the lightweight Population/GeneticMap structures used by the workflow notebooks so it can plug straight into trait sampling, phenotype simulation, and selection routines.*\n\nmaster_key = jax.random.PRNGKey(2024)\npop_key, trait_key, pheno_key = jax.random.split(master_key, 3)\n\nfounder_config = dict(\n    n_ind=48,\n    n_chr=3,\n    n_loci_per_chr=40,\n    mutation_rate=1e-7,\n    recombination_rate_per_chr=1e-8,\n    base_chr_length=500_000,\n    effective_population_size=5_000,\n    num_simulated_individuals=800,\n    maf_threshold=0.05,\n)\n\nfounder_pop, genetic_map = msprime_pop(pop_key, **founder_config)\n\nprint(f'Founder genotype array shape: {founder_pop.geno.shape}')\nallele_counts = founder_pop.geno.sum(axis=2).reshape(founder_pop.geno.shape[0], -1)\nprint(f'Mean allele dosage across founders: {float(allele_counts.mean()):.2f}')\n\nWARNING:2025-10-23 15:49:57,995:jax._src.xla_bridge:794: An NVIDIA GPU may be present on this machine, but a CUDA-enabled jaxlib is not installed. Falling back to cpu.\n\n\nFounder genotype array shape: (48, 3, 2, 40)\nMean allele dosage across founders: 0.62\n\n\n\nmap_summary = pd.DataFrame({\n    'chromosome': np.repeat(np.arange(founder_config['n_chr']), founder_config['n_loci_per_chr']),\n    'position_cM': np.concatenate([np.asarray(pos) for pos in genetic_map.locus_positions]),\n})\n\ndisplay(map_summary.groupby('chromosome')['position_cM'].agg(['min', 'max', 'count']))\n\n\n\n\n\n\n\n\nmin\nmax\ncount\n\n\nchromosome\n\n\n\n\n\n\n\n0\n0.008855\n0.490694\n40\n\n\n1\n0.022942\n0.481344\n40\n\n\n2\n0.008968\n0.499258\n40\n\n\n\n\n\n\n\n\ntrait = add_trait(\n    key=trait_key,\n    founder_pop=founder_pop,\n    n_qtl_per_chr=6,\n    mean=jnp.array([0.0]),\n    var_a=jnp.array([1.0]),\n    var_d=jnp.array([0.0]),\n    sigma=jnp.array([[1.0]], dtype=jnp.float32),\n)\n\nprint(f'Total QTL sampled: {trait.qtl_effects.shape[0]}')\nprint(f'Trait intercept: {float(trait.intercept[0]):.3f}')\n\nTotal QTL sampled: 18\nTrait intercept: 0.173\n\n\n\nheritability = jnp.array([0.4], dtype=jnp.float32)\nphenotypes, tbv = calculate_phenotypes(\n    key=pheno_key,\n    population=founder_pop,\n    trait=trait,\n    heritability=heritability,\n)\n\nresults = pd.DataFrame({\n    'phenotype': np.asarray(phenotypes[:, 0]),\n    'tbv': np.asarray(tbv[:, 0]),\n})\n\ndisplay(results.describe().T[['mean', 'std']])\nprint(f\"Correlation (phenotype, TBV): {results.corr().loc['phenotype', 'tbv']:.3f}\")\n\nplt.figure(figsize=(6, 4))\nplt.scatter(results['tbv'], results['phenotype'], alpha=0.6)\nplt.xlabel('True breeding value')\nplt.ylabel('Phenotype')\nplt.title('Baseline additive trait architecture')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\n\n\n\n\n\n\n\n\nmean\nstd\n\n\n\n\nphenotype\n-0.108091\n1.537079\n\n\ntbv\n-0.173355\n1.010582\n\n\n\n\n\n\n\nCorrelation (phenotype, TBV): 0.693",
    "crumbs": [
      "Wright–Fisher v2 Setup"
    ]
  }
]