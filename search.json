[
  {
    "objectID": "01_pipe.html",
    "href": "01_pipe.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nrun_simulation_cycles\n\n run_simulation_cycles (initial_state:chewc.structs.BreedingState,\n                        trait:chewc.structs.Trait,\n                        genetic_map:chewc.structs.GeneticMap,\n                        heritabilities:jax.Array, n_cycles:int,\n                        n_select:int, n_offspring:int, max_crossovers:int)\n\n*Runs the entire multi-cycle simulation using lax.scan for high performance.\nArgs: initial_state (BreedingState): Starting state of the simulation. trait (Trait): Trait architecture. genetic_map (GeneticMap): Genetic map. heritabilities (jnp.ndarray): Heritability values. n_cycles (int): Number of selection cycles to run. n_select (int): Number of parents to select per cycle. n_offspring (int): Number of offspring to produce per cycle. max_crossovers (int): Maximum crossovers per chromosome.\nReturns: final_state (BreedingState): The state after the last cycle. history (jnp.ndarray): Array of shape (n_cycles, 2) containing [mean_tbv, mean_phenotype] for each generation.*\n\nsource\n\n\nphenotypic_selection_step\n\n phenotypic_selection_step (carry:chewc.structs.BreedingState, _,\n                            trait:chewc.structs.Trait,\n                            genetic_map:chewc.structs.GeneticMap,\n                            heritabilities:jax.Array, n_select:int,\n                            n_offspring:int, max_crossovers:int)\n\n*Executes one full cycle of phenotypic selection and breeding.\nThis function performs the following steps: 1. Phenotyping: Calculates phenotypes and True Breeding Values (TBVs). 2. Selection: Selects top n_select parents based on the first trait (index 0). 3. Mating: Generates a random mating plan. 4. Crossing: Simulates meiosis and crossover to create the next generation. 5. Update: Updates the simulation state (generation, IDs, pedigree).\nArgs: carry (BreedingState): Current simulation state. _ (Any): Ignored loop iterator from lax.scan. trait (Trait): Trait architecture. genetic_map (GeneticMap): Genetic map for recombination. heritabilities (jnp.ndarray): Heritability values for phenotypes. n_select (int): Number of parents to select. n_offspring (int): Number of offspring to generate. max_crossovers (int): Maximum crossovers per chromosome.\nReturns: next_state (BreedingState): The updated simulation state. metrics (jnp.ndarray): Array [mean_tbv, mean_phenotype] for the first trait.*\n\n\n\n\nType\nDetails\n\n\n\n\ncarry\nBreedingState\n\n\n\n_\n\nPlaceholder for lax.scan’s iteration number\n\n\ntrait\nTrait\n\n\n\ngenetic_map\nGeneticMap\n\n\n\nheritabilities\nArray\n\n\n\nn_select\nint\n\n\n\nn_offspring\nint\n\n\n\nmax_crossovers\nint\n\n\n\nReturns\nTuple",
    "crumbs": [
      "01_pipe.html"
    ]
  },
  {
    "objectID": "07_blup.html",
    "href": "07_blup.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nremap_pedigree\n\n remap_pedigree (full_pedigree:jax.Array)\n\nRemaps IDs and returns a NumPy array for the sparse builder.\n\nsource\n\n\nsolve_multi_trait_mme_iterative\n\n solve_multi_trait_mme_iterative (y:jax.Array,\n                                  relationship_matrix_inv:jax.experimental\n                                  .sparse.bcoo.BCOO, G0_inv:jax.Array,\n                                  R0_inv:jax.Array, n_traits:int)\n\nSolves a multi-trait MME using an iterative Conjugate Gradient solver.\n\nsource\n\n\nbuild_g_matrix\n\n build_g_matrix (geno:jax.Array)\n\nConstructs the Genomic Relationship Matrix (G).\n\nsource\n\n\nbuild_a_inverse_sparse\n\n build_a_inverse_sparse (pedigree_meta:numpy.ndarray)\n\nConstructs the inverse of the Numerator Relationship Matrix (A_inv) directly from a pedigree using the correct, numerically stable version of Henderson’s rules. Returns the matrix in JAX’s BCOO sparse format.",
    "crumbs": [
      "07_blup.html"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "chewc",
    "section": "",
    "text": "If you are new to using nbdev here are some useful pointers to get you started.\n\n\n# make sure chewc package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to chewc\n$ nbdev_prepare",
    "crumbs": [
      "chewc"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "chewc",
    "section": "",
    "text": "If you are new to using nbdev here are some useful pointers to get you started.\n\n\n# make sure chewc package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to chewc\n$ nbdev_prepare",
    "crumbs": [
      "chewc"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "chewc",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/cjGO/chewc.git\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages.\n\n\nMulti trait simulation example\nThis code block sets up the simulation parameters, creates a founder population in linkage equilbrium across loci, and simulates 2 correlated traits.\nThen a single generation is simulated from the founder population and ABLUP and GBLUP models are fitted for the offspring.\nBoth the breeding simulation and prediction models are running on JAX.",
    "crumbs": [
      "chewc"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "chewc",
    "section": "How to use",
    "text": "How to use\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom functools import partial\nfrom typing import Tuple\nfrom scipy.sparse import coo_matrix\n\n# JAX's iterative solver and sparse matrix format\nfrom jax.scipy.sparse.linalg import cg\nimport jax.experimental.sparse as jsparse\n\n# Assume the 'chewc' library is installed\nfrom chewc.structs import (\n    Population,\n    Trait,\n    GeneticMap,\n    quick_haplo,\n    add_trait\n)\nfrom chewc.pheno import calculate_phenotypes\nfrom chewc.select import select_top_k\nfrom chewc.cross import random_mating, cross_pair\nfrom chewc.blup import *\n\n\nif __name__ == \"__main__\":\n    # --- Parameters ---\n    N_FOUNDERS, N_SELECT, N_OFFSPRING = 200, 20, 200\n    N_CHR, N_LOCI = 5, 1000\n    SEED = 42\n    N_TRAITS = 2\n    h2_trait1, h2_trait2 = 0.5, 0.5\n    genetic_corr = 0.5\n    \n    # --- Setup (Co)variance matrices ---\n    var_g1, var_g2 = h2_trait1, h2_trait2\n    cov_g12 = genetic_corr * jnp.sqrt(var_g1 * var_g2)\n    G0 = jnp.array([[var_g1, cov_g12], [cov_g12, var_g2]])\n    \n    var_e1, var_e2 = 1 - h2_trait1, 1 - h2_trait2\n    R0 = jnp.diag(jnp.array([var_e1, var_e2]))\n    \n    G0_inv, R0_inv = jnp.linalg.inv(G0), jnp.linalg.inv(R0)\n\n    # --- Population Simulation ---\n    print(\"--- Step 1-4: Simulating population and multi-trait phenotypes ---\")\n    key = jax.random.PRNGKey(SEED)\n    key, pop_key, trait_key, pheno_key, mating_key, cross_key = jax.random.split(key, 6)\n    \n    founder_pop, genetic_map = quick_haplo(key=pop_key, n_ind=N_FOUNDERS, n_chr=N_CHR, seg_sites=N_LOCI)\n    \n    trait_architecture = add_trait(\n        key=trait_key, founder_pop=founder_pop, n_qtl_per_chr=50,\n        mean=jnp.array([100.0, 50.0]), var_a=jnp.array([var_g1, var_g2]), var_d=jnp.array([0.0, 3.0]), sigma=G0\n    )\n    \n    founder_phenotypes, founder_tbvs = calculate_phenotypes(\n        key=pheno_key, population=founder_pop, trait=trait_architecture,\n        heritability=jnp.array([h2_trait1, h2_trait2])\n    )\n    \n    selected_parents = select_top_k(founder_pop, founder_phenotypes[:, 0], k=N_SELECT)\n    pairings = random_mating(mating_key, n_parents=N_SELECT, n_crosses=N_OFFSPRING)\n    \n    vmapped_cross = jax.vmap(cross_pair, in_axes=(0, 0, 0, 0, 0, None, None))\n    offspring_keys = jax.random.split(cross_key, N_OFFSPRING)\n    offspring_geno, offspring_ibd = vmapped_cross(\n        offspring_keys, selected_parents.geno[pairings[:, 0]], selected_parents.geno[pairings[:, 1]],\n        selected_parents.ibd[pairings[:, 0]], selected_parents.ibd[pairings[:, 1]],\n        genetic_map, 10\n    )\n    \n    new_meta = jnp.stack([\n        jnp.arange(N_OFFSPRING) + N_FOUNDERS,\n        selected_parents.meta[pairings[:, 0], 0],\n        selected_parents.meta[pairings[:, 1], 0],\n        jnp.full((N_OFFSPRING,), 1),\n    ], axis=-1)\n    offspring_pop = Population(geno=offspring_geno, ibd=offspring_ibd, meta=new_meta)\n    \n    key, offspring_pheno_key = jax.random.split(key)\n    offspring_phenotypes, offspring_tbvs = calculate_phenotypes(\n        key=offspring_pheno_key, population=offspring_pop, trait=trait_architecture,\n        heritability=jnp.array([h2_trait1, h2_trait2])\n    )\n    \n    all_phenotypes = jnp.concatenate([founder_phenotypes, offspring_phenotypes], axis=0)\n    print(\"--- Population simulation complete ---\")\n\n    # --- ABLUP (Sparse, Iterative) ---\n    print(\"\\n--- Performing Multi-Trait ABLUP (Sparse Iterative) ---\")\n    full_pedigree = jnp.concatenate([founder_pop.meta, offspring_pop.meta], axis=0)\n    remapped_ped_np = remap_pedigree(full_pedigree)\n    \n    A_inv_sparse = build_a_inverse_sparse(remapped_ped_np)\n    ablup_ebvs = solve_multi_trait_mme_iterative(\n        all_phenotypes, A_inv_sparse, G0_inv, R0_inv, n_traits=N_TRAITS\n    )\n    print(\"ABLUP calculation complete.\")\n    \n    # --- GBLUP (Iterative) ---\n    print(\"\\n--- Performing Multi-Trait GBLUP (Iterative) ---\")\n    all_geno = jnp.concatenate([founder_pop.geno, offspring_pop.geno], axis=0)\n    G_matrix = build_g_matrix(all_geno)\n    G_inv = jnp.linalg.inv(G_matrix + jnp.identity(G_matrix.shape[0]) * 1e-4)\n    \n    gblup_gebvs = solve_multi_trait_mme_iterative(\n        all_phenotypes, G_inv, G0_inv, R0_inv, n_traits=N_TRAITS\n    )\n    print(\"GBLUP calculation complete.\")\n\n    # --- Compare Results ---\n    print(\"\\n--- Comparison of Results for Offspring ---\")\n    offspring_ablup = ablup_ebvs[N_FOUNDERS:]\n    offspring_gblup = gblup_gebvs[N_FOUNDERS:]\n\n    acc_ablup_t1 = jnp.corrcoef(offspring_tbvs[:, 0], offspring_ablup[:, 0])[0, 1]\n    acc_ablup_t2 = jnp.corrcoef(offspring_tbvs[:, 1], offspring_ablup[:, 1])[0, 1]\n    acc_gblup_t1 = jnp.corrcoef(offspring_tbvs[:, 0], offspring_gblup[:, 0])[0, 1]\n    acc_gblup_t2 = jnp.corrcoef(offspring_tbvs[:, 1], offspring_gblup[:, 1])[0, 1]\n\n    print(f\"\\nABLUP Accuracy -&gt; Trait 1: {acc_ablup_t1:.4f}, Trait 2: {acc_ablup_t2:.4f}\")\n    print(f\"GBLUP Accuracy -&gt; Trait 1: {acc_gblup_t1:.4f}, Trait 2: {acc_gblup_t2:.4f}\")\n    print('Note: both traits have the same heritabilities; but trait 2 has strong dominance effects, lowering accuracy')\n\n    print(\"\\n{:&lt;6} | {:&gt;12} {:&gt;12} | {:&gt;12} {:&gt;12} | {:&gt;12} {:&gt;12}\".format(\n        \"ID\", \"TBV T1\", \"TBV T2\", \"ABLUP T1\", \"ABLUP T2\", \"GBLUP T1\", \"GBLUP T2\"))\n    print(\"-\" * 88)\n    for i in range(10):\n        print(\"{:&lt;6} | {:&gt;12.3f} {:&gt;12.3f} | {:&gt;12.3f} {:&gt;12.3f} | {:&gt;12.3f} {:&gt;12.3f}\".format(\n            int(offspring_pop.meta[i, 0]),\n            offspring_tbvs[i, 0], offspring_tbvs[i, 1],\n            offspring_ablup[i, 0], offspring_ablup[i, 1],\n            offspring_gblup[i, 0], offspring_gblup[i, 1]\n        ))\n\n--- Step 1-4: Simulating population and multi-trait phenotypes ---\n--- Population simulation complete ---\n\n--- Performing Multi-Trait ABLUP (Sparse Iterative) ---\n[DEBUG] Sparse A_inv successfully created with 1406 non-zero elements.\n[DEBUG] First 5 data points of A_inv: [1. 1. 1. 1. 1.]\nABLUP calculation complete.\n\n--- Performing Multi-Trait GBLUP (Iterative) ---\nGBLUP calculation complete.\n\n--- Comparison of Results for Offspring ---\n\nABLUP Accuracy -&gt; Trait 1: 0.7611, Trait 2: 0.5660\nGBLUP Accuracy -&gt; Trait 1: 0.8045, Trait 2: 0.5809\nNote: both traits have the same heritabilities; but trait 2 has strong dominance effects, lowering accuracy\n\nID     |       TBV T1       TBV T2 |     ABLUP T1     ABLUP T2 |     GBLUP T1     GBLUP T2\n----------------------------------------------------------------------------------------\n200    |        0.847        1.461 |        0.322        1.116 |       -0.352        0.364\n201    |        1.682        2.124 |        0.722        0.735 |        0.215        0.453\n202    |        2.488        1.058 |        1.688        1.321 |        1.163        1.017\n203    |        2.594        1.706 |        0.780       -0.772 |        0.553       -1.136\n204    |        2.269        0.813 |        1.850        1.366 |        1.186        1.020\n205    |        2.632        1.291 |        1.492        1.700 |        0.939        0.960\n206    |        2.682        2.317 |        1.919        2.742 |        1.315        2.362\n207    |        3.482        2.645 |        2.379        3.829 |        1.891        3.462\n208    |        1.728        1.467 |        0.913        0.271 |        0.322       -0.260\n209    |        2.602        2.125 |        0.888        0.409 |        0.511        0.211",
    "crumbs": [
      "chewc"
    ]
  },
  {
    "objectID": "09_gym.html",
    "href": "09_gym.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nStoaEnv\n\n StoaEnv (n_founders=100, n_pop_size=200, n_chr=5, n_loci=1000,\n          n_qtl_per_chr=50, total_gen=20, max_crossovers=10)\n\n*A Gymnax environment for the ChewC breeding simulation.\nThe agent’s goal is to maximize the genetic gain of the population over a fixed number of generations by choosing the selection intensity at each step.*\n\nsource\n\n\nevaluate_constant_actions\n\n evaluate_constant_actions (env:__main__.StoaEnv, action_values,\n                            num_episodes:int=32, seed:int=0,\n                            confidence_level:float=0.95)\n\nEvaluates constant actions over multiple episodes.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nenv\nStoaEnv\n\n\n\n\naction_values\n\n\n\n\n\nnum_episodes\nint\n32\n\n\n\nseed\nint\n0\n\n\n\nconfidence_level\nfloat\n0.95\nFor confidence interval\n\n\nReturns\nDataFrame\n\n\n\n\n\n\nsource\n\n\nrun_constant_action_episode\n\n run_constant_action_episode (env:__main__.StoaEnv, action_value:float,\n                              rng_key:jax.Array)\n\nRuns a single episode with a constant action and returns metrics and history.\n\nsource\n\n\nStoaEnv\n\n StoaEnv (n_founders=100, n_pop_size=200, n_chr=5, n_loci=1000,\n          n_qtl_per_chr=50, total_gen=20, max_crossovers=10)\n\n*A Gymnax environment for the ChewC breeding simulation.\nThe agent’s goal is to maximize the genetic gain of the population over a fixed number of generations by choosing the selection intensity at each step.*",
    "crumbs": [
      "09_gym.html"
    ]
  },
  {
    "objectID": "08_wrappers.html",
    "href": "08_wrappers.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nNormalizeVecReward\n\n NormalizeVecReward (env, gamma)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nNormalizeVecRewEnvState\n\n NormalizeVecRewEnvState (mean:jax.Array, var:jax.Array, count:float,\n                          return_val:float, env_state:gymnax.environments.\n                          environment.EnvState)\n\n\nsource\n\n\nNormalizeVecObservation\n\n NormalizeVecObservation (env)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nNormalizeVecObsEnvState\n\n NormalizeVecObsEnvState (mean:jax.Array, var:jax.Array, count:float,\n                          env_state:gymnax.environments.environment.EnvSta\n                          te)\n\n\nsource\n\n\nVecEnv\n\n VecEnv (env)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nTransformReward\n\n TransformReward (env, transform_reward)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nTransformObservation\n\n TransformObservation (env, transform_obs)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nClipAction\n\n ClipAction (env, low=-1.0, high=1.0)\n\nBase class for Gymnax wrappers.\n\nsource\n\n\nNavixGymnaxWrapper\n\n NavixGymnaxWrapper (env_name)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nBraxGymnaxWrapper\n\n BraxGymnaxWrapper (env_name, backend='positional')\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nLogWrapper\n\n LogWrapper (env:gymnax.environments.environment.Environment)\n\nLog the episode returns and lengths.\n\nsource\n\n\nLogEnvState\n\n LogEnvState (env_state:gymnax.environments.environment.EnvState,\n              episode_returns:float, episode_lengths:int,\n              returned_episode_returns:float,\n              returned_episode_lengths:int, timestep:int)\n\n\nsource\n\n\nFlattenObservationWrapper\n\n FlattenObservationWrapper\n                            (env:gymnax.environments.environment.Environme\n                            nt)\n\nFlatten the observations of the environment.\n\nsource\n\n\nGymnaxWrapper\n\n GymnaxWrapper (env)\n\nBase class for Gymnax wrappers.",
    "crumbs": [
      "08_wrappers.html"
    ]
  },
  {
    "objectID": "000_wf.html",
    "href": "000_wf.html",
    "title": "chewc",
    "section": "",
    "text": "import jax\nimport jax.numpy as jnp\nimport numpy as np\n\n# Import core chewc components\nfrom chewc.structs import add_trait\nfrom chewc.burnin import run_burnin\n\n# UPDATED: Import the pipeline runner from chewc.pipe\nfrom chewc.pipe import run_simulation_cycles\n\n# --- 1. Experiment Parameters ---\nN_POP = 150             # Constant population size\nN_ENVIRONMENTS = 1      # Single Location/Trait\nN_CHR = 5\nN_LOCI = 1000\nN_QTL = 50\nSEED = 123\n\n# Simulation Settings\nBURN_IN_GENS = 50\nMAX_CROSSOVERS = 10\n\n# Selection Settings\nN_SELECTION_GENS = 50\nN_SELECT = 20           # Select top 20 parents\nN_OFFSPRING = 150       # Next gen size\n\n# --- 2. Burn-in (Initialize & Establish LD) ---\nprint(f\"--- Setting up Single-Trait Experiment ---\")\nprint(f\"Population Size: {N_POP}\")\nprint(f\"Environments: {N_ENVIRONMENTS} (Single Trait)\")\nprint(f\"\\n[Phase 1] Running {BURN_IN_GENS} generations of burn-in...\")\n\nkey = jax.random.PRNGKey(SEED)\nkey, burnin_key, trait_key = jax.random.split(key, 3)\n\n# Single call to handle initialization and burn-in\nstable_state, final_ld, genetic_map = run_burnin(\n    key=burnin_key,\n    n_gens=BURN_IN_GENS,\n    n_pop=N_POP,\n    n_chr=N_CHR,\n    n_loci=N_LOCI,\n    max_crossovers=MAX_CROSSOVERS\n)\n\nprint(f\"Burn-in complete at Generation {stable_state.generation}\")\nprint(f\"Mean Adjacent LD (r^2) per chromosome: {final_ld}\")\n\n\n# --- 3. Define Single Trait Architecture ---\nprint(f\"\\n[Phase 2] Defining Single Trait Architecture...\")\n\n# 1x1 Correlation matrix (scalar 1.0)\ngenetic_correlation = jnp.eye(N_ENVIRONMENTS)\n\ntrait_arch = add_trait(\n    key=trait_key,\n    founder_pop=stable_state.population,\n    n_qtl_per_chr=N_QTL,\n    mean=jnp.zeros(N_ENVIRONMENTS),\n    var_a=jnp.ones(N_ENVIRONMENTS),\n    var_d=jnp.zeros(N_ENVIRONMENTS),\n    sigma=genetic_correlation\n)\n\n# Single heritability value\nHERITABILITIES = jnp.array([0.5])\n\n\n# --- 4. Execute Selection Loop ---\nprint(f\"\\n--- Starting {N_SELECTION_GENS} Generations of Selection ---\")\n\n# REFACTORED: Use run_simulation_cycles from chewc.pipe\n# This handles the partial binding and lax.scan internally\nfinal_state, history = run_simulation_cycles(\n    initial_state=stable_state,\n    trait=trait_arch,\n    genetic_map=genetic_map,\n    heritabilities=HERITABILITIES,\n    n_cycles=N_SELECTION_GENS,\n    n_select=N_SELECT,\n    n_offspring=N_OFFSPRING,\n    max_crossovers=MAX_CROSSOVERS\n)\n\n\n# --- 5. Results Analysis ---\nprint(\"\\nGeneration | Mean TBV (Genetic Gain) | Mean Phenotype\")\nprint(\"---------------------------------------------------\")\nmetrics_history = np.array(history)\n\nfor i in range(N_SELECTION_GENS):\n    gen = stable_state.generation + i + 1\n    tbv = metrics_history[i, 0]\n    pheno = metrics_history[i, 1]\n    print(f\"Gen {gen:&lt;3}    | {tbv:&lt;23.4f} | {pheno:.4f}\")\n\ntotal_gain = metrics_history[-1, 0] - metrics_history[0, 0]\nprint(f\"\\nTotal Genetic Gain: {total_gain:.4f}\")\n\n/home/glect/.local/lib/python3.10/site-packages/matplotlib/projections/__init__.py:63: UserWarning: Unable to import Axes3D. This may be due to multiple versions of Matplotlib being installed (e.g. as a system package and as a pip package). As a result, the 3D projection is not available.\n  warnings.warn(\"Unable to import Axes3D. This may be due to multiple versions of \"\nWARNING:2025-11-26 16:51:28,127:jax._src.xla_bridge:794: An NVIDIA GPU may be present on this machine, but a CUDA-enabled jaxlib is not installed. Falling back to cpu.\n\n\n--- Setting up Single-Trait Experiment ---\nPopulation Size: 150\nEnvironments: 1 (Single Trait)\n\n[Phase 1] Running 50 generations of burn-in...\nBurn-in complete at Generation 50\nMean Adjacent LD (r^2) per chromosome: [0.15110835 0.14266446 0.14125235 0.14965521 0.1522844 ]\n\n[Phase 2] Defining Single Trait Architecture...\n\n--- Starting 50 Generations of Selection ---\n\nGeneration | Mean TBV (Genetic Gain) | Mean Phenotype\n---------------------------------------------------\nGen 51     | 0.3050                  | 0.0893\nGen 52     | 1.5707                  | 1.3299\nGen 53     | 2.5418                  | 2.2419\nGen 54     | 3.4875                  | 3.1454\nGen 55     | 4.3080                  | 3.9606\nGen 56     | 5.1795                  | 4.8874\nGen 57     | 5.7102                  | 5.3484\nGen 58     | 6.5932                  | 6.2297\nGen 59     | 7.3113                  | 7.1080\nGen 60     | 7.8562                  | 7.5016\nGen 61     | 8.4342                  | 8.0798\nGen 62     | 8.9574                  | 8.6164\nGen 63     | 9.4117                  | 9.1064\nGen 64     | 9.9187                  | 9.5113\nGen 65     | 10.3476                 | 10.0543\nGen 66     | 10.7954                 | 10.5121\nGen 67     | 11.1176                 | 10.8407\nGen 68     | 11.4818                 | 11.2164\nGen 69     | 11.8435                 | 11.5521\nGen 70     | 12.1928                 | 11.9043\nGen 71     | 12.4904                 | 12.1992\nGen 72     | 12.7797                 | 12.4851\nGen 73     | 13.0009                 | 12.7128\nGen 74     | 13.1698                 | 12.8855\nGen 75     | 13.4130                 | 13.0821\nGen 76     | 13.6155                 | 13.3147\nGen 77     | 13.8012                 | 13.4902\nGen 78     | 13.9466                 | 13.6426\nGen 79     | 14.0811                 | 13.7798\nGen 80     | 14.2046                 | 13.8981\nGen 81     | 14.3261                 | 14.0233\nGen 82     | 14.4108                 | 14.1011\nGen 83     | 14.4789                 | 14.1806\nGen 84     | 14.5301                 | 14.2264\nGen 85     | 14.5796                 | 14.2757\nGen 86     | 14.6326                 | 14.3242\nGen 87     | 14.6717                 | 14.3613\nGen 88     | 14.7112                 | 14.4060\nGen 89     | 14.7555                 | 14.4467\nGen 90     | 14.7982                 | 14.4895\nGen 91     | 14.8162                 | 14.5124\nGen 92     | 14.8249                 | 14.5201\nGen 93     | 14.8360                 | 14.5312\nGen 94     | 14.8391                 | 14.5343\nGen 95     | 14.8411                 | 14.5362\nGen 96     | 14.8418                 | 14.5369\nGen 97     | 14.8421                 | 14.5372\nGen 98     | 14.8421                 | 14.5372\nGen 99     | 14.8421                 | 14.5372\nGen 100    | 14.8421                 | 14.5372\n\nTotal Genetic Gain: 14.5372",
    "crumbs": [
      "000_wf.html"
    ]
  },
  {
    "objectID": "03_meiosis.html",
    "href": "03_meiosis.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\ncreate_gamete\n\n create_gamete (key:jax.Array, parent_geno:jax.Array,\n                parent_ibd:jax.Array,\n                genetic_map:chewc.structs.GeneticMap,\n                interference_nu:float, max_crossovers:int)\n\nReturn a haploid gamete (geno, ibd) of shape (n_chr, n_loci).\n\n\n\n\nType\nDetails\n\n\n\n\nkey\nArray\n\n\n\nparent_geno\nArray\n(n_chr, 2, n_loci)\n\n\nparent_ibd\nArray\n(n_chr, 2, n_loci)\n\n\ngenetic_map\nGeneticMap\n\n\n\ninterference_nu\nfloat\n\n\n\nmax_crossovers\nint\n\n\n\nReturns\nTuple",
    "crumbs": [
      "03_meiosis.html"
    ]
  },
  {
    "objectID": "06_cross.html",
    "href": "06_cross.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\ncreate_ocs_mating_plan\n\n create_ocs_mating_plan (key:jax.Array, candidate_ids:jax.Array,\n                         contributions:jax.Array, n_crosses:int,\n                         allow_selfing:bool=False)\n\nGenerates a mating list based on optimal contribution scores for unisex populations.\n\nsource\n\n\ncross_pair\n\n cross_pair (key:jax.Array, mother_geno:jax.Array, father_geno:jax.Array,\n             mother_ibd:jax.Array, father_ibd:jax.Array,\n             genetic_map:chewc.structs.GeneticMap, max_crossovers:int)\n\n\n\n\n\nType\nDetails\n\n\n\n\nkey\nArray\n\n\n\nmother_geno\nArray\n\n\n\nfather_geno\nArray\n(n_chr, 2, n_loci)\n\n\nmother_ibd\nArray\n\n\n\nfather_ibd\nArray\n(n_chr, 2, n_loci)\n\n\ngenetic_map\nGeneticMap\n\n\n\nmax_crossovers\nint\n\n\n\nReturns\nTuple\n\n\n\n\n\nsource\n\n\nrandom_mating\n\n random_mating (key:jax.Array, n_parents:int, n_crosses:int)\n\nSample (mother, father) pairs with replacement. Works even when n_parents is not a Python literal.",
    "crumbs": [
      "06_cross.html"
    ]
  },
  {
    "objectID": "04_phenotype.html",
    "href": "04_phenotype.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\ncalculate_phenotypes\n\n calculate_phenotypes (key:jax.Array, population:chewc.structs.Population,\n                       trait:chewc.structs.Trait, heritability:jax.Array)\n\nReturn (phenotypes, true_breeding_values). Calculates phenotypes by modeling G = A + D.\n\n\n\n\nType\nDetails\n\n\n\n\nkey\nArray\n\n\n\npopulation\nPopulation\n\n\n\ntrait\nTrait\n\n\n\nheritability\nArray\nNarrow-sense h^2, shape: (n_traits,)\n\n\nReturns\nTuple\n\n\n\n\n\nsource\n\n\ncompute_dosage\n\n compute_dosage (population:chewc.structs.Population)\n\nComputes allele dosage. Shape: (n_ind, n_chr, n_loci)",
    "crumbs": [
      "04_phenotype.html"
    ]
  },
  {
    "objectID": "02_structs.html",
    "href": "02_structs.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nBreedingState\n\n BreedingState (population:__main__.Population, key:jax.Array,\n                generation:int, next_id:int)\n\n*The complete, self-contained state of a single simulation replicate at a point in time.\nThis object is the primary carrier passed between steps in the simulation.\nAttributes: population (Population): The current population of individuals. key (jax.Array): The JAX pseudo-random number generator key. generation (int): The current generation number of the simulation.*\n\nsource\n\n\nTrait\n\n Trait (qtl_chromosome:jax.Array, qtl_position:jax.Array,\n        qtl_effects:jax.Array, qtl_dominance_effects:jax.Array,\n        intercept:jax.Array)\n\n*Defines the genetic architecture of one or more traits.\nThis structure holds the information linking genotypes to phenotypes, based on an additive and dominance QTL model.\nAttributes: qtl_chromosome (jnp.ndarray): Chromosome index for each QTL. Shape: (n_qtl,) qtl_position (jnp.ndarray): Locus index for each QTL within its chromosome. Shape: (n_qtl,) qtl_effects (jnp.ndarray): The additive effect of each QTL on each trait. Shape: (n_qtl, n_traits) qtl_dominance_effects (jnp.ndarray): The dominance effect of each QTL on each trait. Shape: (n_qtl, n_traits) intercept (jnp.ndarray): The base value for each trait. Shape: (n_traits,)*\n\nsource\n\n\nPopulation\n\n Population (geno:jax.Array, ibd:jax.Array, meta:jax.Array)\n\n*Represents a collection of individuals within a breeding program.\nAttributes: geno (jnp.ndarray): Genotypes. Shape: (n_individuals, n_chr, 2, n_loci) ibd (jnp.ndarray): Identity-by-descent tracking for founder alleles. Shape: (n_individuals, n_chr, 2, n_loci) meta (jnp.ndarray): Metadata [id, mother_id, father_id, birth_gen]. Shape: (n_individuals, 4)*\n\nsource\n\n\nGeneticMap\n\n GeneticMap (chromosome_lengths:jax.Array,\n             locus_positions:List[jax.Array])\n\n*Defines the genetic map of the organism.\nAttributes: chromosome_lengths (jnp.ndarray): The genetic length of each chromosome in Morgans. Shape: (n_chr,) locus_positions (List[jnp.ndarray]): A list where each element is a JAX array containing the Morgan positions of loci for a single chromosome.*\n\nsource\n\n\nmsprime_pop\n\n msprime_pop (key:jax.Array, n_ind:int, n_chr:int, n_loci_per_chr:int,\n              ploidy:int=2, effective_population_size:int=15000,\n              mutation_rate:float=1e-07,\n              recombination_rate_per_chr:float=1e-08,\n              maf_threshold:float=0.05, base_chr_length:int=500000,\n              num_simulated_individuals:Optional[int]=None,\n              enforce_founder_maf:bool=True)\n\n*Simulate a founder population from an msprime ancestry model.\nThe output matches the lightweight Population/GeneticMap structures used by the workflow notebooks so it can plug straight into trait sampling, phenotype simulation, and selection routines.*\n\nsource\n\n\nquick_haplo\n\n quick_haplo (key:jax.Array, n_ind:int, n_chr:int, seg_sites:int,\n              inbred:bool=False, chr_length:float=1.0)\n\nCreate a simple founder population and a uniform genetic map.\n\nsource\n\n\nadd_trait\n\n add_trait (key:jax.Array, founder_pop:__main__.Population,\n            n_qtl_per_chr:int, mean:jax.Array, var_a:jax.Array,\n            var_d:jax.Array, sigma:jax.Array)\n\nSample QTLs and multi-trait effects for both additive and dominance components.\n\n\n\n\nType\nDetails\n\n\n\n\nkey\nArray\n\n\n\nfounder_pop\nPopulation\n\n\n\nn_qtl_per_chr\nint\n\n\n\nmean\nArray\n(n_traits,)\n\n\nvar_a\nArray\nAdditive variance (n_traits,)\n\n\nvar_d\nArray\nDominance variance (n_traits,)\n\n\nsigma\nArray\n(n_traits, n_traits) PSD\n\n\nReturns\nTrait\n\n\n\n\n\nsource\n\n\ncompute_dosage\n\n compute_dosage (population:__main__.Population)\n\n*Computes the dosage of the ‘1’ allele for each individual at each locus.\nDosage is calculated as the sum of alleles across the two homologous chromosomes, resulting in values of 0, 1, or 2.\nArgs: population: A Population object.\nReturns: A 3D array of dosages with shape (n_individuals, n_chr, n_loci).*\n\nkey = jax.random.PRNGKey(42)\nfounder_pop = quick_haplo(\nkey=key,\nn_ind=10,\nn_chr=3,\nseg_sites=100,\ninbred=False\n )",
    "crumbs": [
      "02_structs.html"
    ]
  },
  {
    "objectID": "05_select.html",
    "href": "05_select.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nselect_with_ocs\n\n select_with_ocs (population:chewc.structs.Population,\n                  breeding_values:jax.Array, delta_F:float, k:int)\n\nSelects top-k individuals and calculates their optimal contributions.\n\nsource\n\n\nfind_optimal_contributions\n\n find_optimal_contributions (g:jax.Array, A:jax.Array, delta_F:float,\n                             start_lambda:float=1.0,\n                             tolerance:float=1e-06,\n                             max_iterations:int=100)\n\nJIT-compiled function using jax.lax.while_loop to find optimal contributions.\n\nsource\n\n\nselect_top_k\n\n select_top_k (population:chewc.structs.Population, values:jax.Array,\n               k:int)\n\nSelect top-k individuals by values (1-D).",
    "crumbs": [
      "05_select.html"
    ]
  },
  {
    "objectID": "10_burnin.html",
    "href": "10_burnin.html",
    "title": "chewc",
    "section": "",
    "text": "source\n\nrun_burnin\n\n run_burnin (key:jax.Array, n_gens:int, n_pop:int, n_chr:int=5,\n             n_loci:int=1000, chr_length:float=1.0, max_crossovers:int=10,\n             founder_pop:Optional[chewc.structs.Population]=None,\n             genetic_map:Optional[chewc.structs.GeneticMap]=None)\n\n*Runs a burn-in simulation to establish Linkage Disequilibrium (LD).\nIf no founder population is provided, one is created using quick_haplo.\nArgs: key (jax.Array): Random number generator key. n_gens (int): Number of generations to burn in. n_pop (int): Population size (constant throughout). n_chr (int): Number of chromosomes (used if creating founders). n_loci (int): Number of loci per chromosome (used if creating founders). chr_length (float): Length of chromosomes in Morgans. max_crossovers (int): Max crossovers per chromosome during meiosis. founder_pop (Optional[Population]): Custom starting population. genetic_map (Optional[GeneticMap]): Custom genetic map.\nReturns: Tuple containing: - final_state (BreedingState): The simulation state after burn-in. - final_ld (jnp.ndarray): Array of mean r^2 between adjacent markers per chromosome. - genetic_map (GeneticMap): The genetic map used/created.*\n\nsource\n\n\ncalculate_adjacent_ld\n\n calculate_adjacent_ld (population:chewc.structs.Population)\n\n*Calculates the Linkage Disequilibrium (r^2) between adjacent markers across the genome.\nArgs: population (Population): The population to analyze.\nReturns: jnp.ndarray: An array of mean r^2 values per chromosome. Shape: (n_chr,)*",
    "crumbs": [
      "10_burnin.html"
    ]
  }
]