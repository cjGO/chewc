# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_structs.ipynb.

# %% auto 0
__all__ = ['GeneticMap', 'Population', 'Trait', 'BreedingState', 'quick_haplo', 'compute_dosage', 'add_trait']

# %% ../nbs/02_structs.ipynb 1
from flax.struct import dataclass
import jax
import jax.numpy as jnp
from typing import Optional, Tuple, List

@dataclass(frozen=True)
class GeneticMap:
    """
    Defines the genetic map of the organism.

    Attributes:
        chromosome_lengths (jnp.ndarray): The genetic length of each chromosome in Morgans.
            Shape: (n_chr,)
        locus_positions (List[jnp.ndarray]): A list where each element is a JAX array
            containing the Morgan positions of loci for a single chromosome.
    """
    chromosome_lengths: jnp.ndarray
    locus_positions: List[jnp.ndarray]


@dataclass(frozen=True)
class Population:
    """
    Represents a collection of individuals within a breeding program.

    Attributes:
        geno (jnp.ndarray): Genotypes.
            Shape: (n_individuals, n_chr, 2, n_loci)
        ibd (jnp.ndarray): Identity-by-descent tracking for founder alleles.
            Shape: (n_individuals, n_chr, 2, n_loci)
        meta (jnp.ndarray): Metadata [id, mother_id, father_id, birth_gen].
            Shape: (n_individuals, 4)
    """
    geno: jnp.ndarray
    ibd: jnp.ndarray
    meta: jnp.ndarray

@dataclass(frozen=True)
class Trait:
    """
    Defines the genetic architecture of one or more traits.

    This structure holds the information linking genotypes to phenotypes,
    based on an additive QTL model.

    Attributes:
        qtl_chromosome (jnp.ndarray): Chromosome index for each QTL.
            Shape: (n_qtl,)
        qtl_position (jnp.ndarray): Locus index for each QTL within its chromosome.
            Shape: (n_qtl,)
        qtl_effects (jnp.ndarray): The additive effect of each QTL on each trait.
            Shape: (n_qtl, n_traits)
        intercept (jnp.ndarray): The base value for each trait.
            Shape: (n_traits,)
    """
    qtl_chromosome: jnp.ndarray
    qtl_position: jnp.ndarray
    qtl_effects: jnp.ndarray
    intercept: jnp.ndarray

@dataclass(frozen=True)
class BreedingState:
    """
    The complete, self-contained state of a single simulation replicate at a point in time.

    This object is the primary carrier passed between steps in the simulation.

    Attributes:
        population (Population): The current population of individuals.
        key (jax.Array): The JAX pseudo-random number generator key.
        generation (int): The current generation number of the simulation.
    """
    population: Population
    key: jax.Array
    generation: int
    next_id: int # To ensure unique IDs for new individuals


# %% ../nbs/02_structs.ipynb 2
import jax
import jax.numpy as jnp
from typing import Tuple



def quick_haplo(
    key: jax.Array,
    n_ind: int,
    n_chr: int,
    seg_sites: int,
    inbred: bool = False,
    chr_length: float = 1.0,
) -> Tuple[Population, GeneticMap]:
    """Create a simple founder population and a uniform genetic map."""
    if inbred:
        haplotypes = jax.random.randint(
            key, (n_ind, n_chr, 1, seg_sites), 0, 2, dtype=jnp.int8
        )
        geno = jnp.broadcast_to(haplotypes, (n_ind, n_chr, 2, seg_sites))
    else:
        geno = jax.random.randint(
            key, (n_ind, n_chr, 2, seg_sites), 0, 2, dtype=jnp.int8
        )

    # IBD labels: unique per haplotype across individuals
    ibd = jnp.broadcast_to(
        jnp.arange(n_ind * 2, dtype=jnp.int32).reshape(n_ind, 1, 2, 1),
        (n_ind, n_chr, 2, seg_sites),
    )

    # Meta (int32 all the way, stack doesn't accept dtype= kwarg)
    meta = jnp.stack(
        [
            jnp.arange(n_ind, dtype=jnp.int32),               # id
            jnp.full((n_ind,), -1, dtype=jnp.int32),          # mother_id
            jnp.full((n_ind,), -1, dtype=jnp.int32),          # father_id
            jnp.zeros((n_ind,), dtype=jnp.int32),             # birth_gen
        ],
        axis=-1,
    )

    population = Population(geno=geno, ibd=ibd, meta=meta)

    # Genetic map: same number of loci per chromosome, uniform spacing
    chromosome_lengths = jnp.full((n_chr,), chr_length, dtype=jnp.float32)
    locus_positions = jnp.stack(
        [jnp.linspace(0.0, chr_length, seg_sites, dtype=jnp.float32) for _ in range(n_chr)],
        axis=0,
    )
    genetic_map = GeneticMap(
        chromosome_lengths=chromosome_lengths, locus_positions=locus_positions
    )
    return population, genetic_map



# %% ../nbs/02_structs.ipynb 3
import jax.numpy as jnp
import jax

@jax.jit
def compute_dosage(population: Population) -> jnp.ndarray:
    """
    Computes the dosage of the '1' allele for each individual at each locus.

    Dosage is calculated as the sum of alleles across the two homologous
    chromosomes, resulting in values of 0, 1, or 2.

    Args:
        population: A `Population` object.

    Returns:
        A 3D array of dosages with shape (n_individuals, n_chr, n_loci).
    """
    # geno shape: (n_individuals, n_chr, 2, n_loci)
    # Sum across the chromosome pair axis (axis=2)
    return jnp.sum(population.geno, axis=2)


def _flatten_gather_chr_locus(dosage_chr_locus: jnp.ndarray,
                              chr_idx: jnp.ndarray,
                              locus_idx: jnp.ndarray) -> jnp.ndarray:
    """
    dosage_chr_locus: (n_ind, n_chr, n_loci)
    chr_idx, locus_idx: (n_qtl,)
    returns: (n_ind, n_qtl) gathered pairwise along (chr,locus).
    """
    n_chr, n_loci = dosage_chr_locus.shape[1], dosage_chr_locus.shape[2]
    flat = dosage_chr_locus.reshape(dosage_chr_locus.shape[0], n_chr * n_loci)
    flat_ids = chr_idx * n_loci + locus_idx
    return jnp.take(flat, flat_ids, axis=1)





def add_trait(
    key: jax.Array,
    founder_pop: Population,
    n_qtl_per_chr: int,
    mean: jnp.ndarray,   # (n_traits,)
    var: jnp.ndarray,    # (n_traits,)
    sigma: jnp.ndarray,  # (n_traits, n_traits) PSD
) -> Trait:
    """Sample QTLs and multi-trait effects with covariance `sigma`."""
    key, qtl_key, effect_key = jax.random.split(key, 3)

    n_chr = founder_pop.geno.shape[1]
    n_loci_per_chr = founder_pop.geno.shape[3]

    n_total_qtl = n_qtl_per_chr * n_chr
    all_loci_indices = jnp.arange(n_chr * n_loci_per_chr, dtype=jnp.int32)
    qtl_loc_flat = jax.random.choice(
        qtl_key, all_loci_indices, (n_total_qtl,), replace=False
    )
    qtl_chromosome, qtl_position = jnp.divmod(jnp.sort(qtl_loc_flat), n_loci_per_chr)

    n_traits = int(mean.shape[0])
    raw_effects = jax.random.normal(effect_key, (n_total_qtl, n_traits), dtype=jnp.float32)
    cholesky_factor = jnp.linalg.cholesky(sigma.astype(jnp.float32))  # (T, T)
    effects = raw_effects @ cholesky_factor.T  # (n_qtl, T)

    # Use founders to scale effects to desired trait variances
    founder_dosage = jnp.sum(founder_pop.geno, axis=2, dtype=jnp.int32)  # (n, chr, loci)
    qtl_dosage = _flatten_gather_chr_locus(founder_dosage, qtl_chromosome, qtl_position).astype(jnp.float32)
    gvs = qtl_dosage @ effects  # (n, T)

    # Scale to hit target marginal variances
    scale = jnp.sqrt(var.astype(jnp.float32) / (jnp.var(gvs, axis=0) + 1e-8))
    intercept = mean.astype(jnp.float32) - jnp.mean(gvs, axis=0) * scale
    final_effects = effects * scale  # (n_qtl, T)

    return Trait(
        qtl_chromosome=qtl_chromosome.astype(jnp.int32),
        qtl_position=qtl_position.astype(jnp.int32),
        qtl_effects=final_effects,
        intercept=intercept,
    )

