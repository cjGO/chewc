"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_pheno.ipynb.

# %% auto 0
__all__ = ['set_pheno']

# %% ../nbs/04_pheno.ipynb 3
from typing import Optional

import jax
import jax.numpy as jnp
from jaxtyping import Array, Float, Int

# Assuming these are in their respective files
from .pop import Population
from .trait import TraitCollection
from functools import partial

def _calculate_single_gv(
    add_eff_slice: Float[Array, "nLoci"],
    intercept_slice: float,
    qtl_geno: Int[Array, "nInd nLoci"]
) -> Float[Array, "nInd"]:
    """Calculates GV for one trait given its parameters and the shared QTL genotypes."""
    bv = jnp.dot(qtl_geno, add_eff_slice)
    return bv + intercept_slice

def _calculate_gvs_vectorized(
    pop: Population,
    traits: TraitCollection,
    ploidy: int
) -> Float[Array, "nInd nTraits"]:
    """Calculates all genetic values for all traits in a vectorized manner."""
    flat_geno_alleles = pop.geno.transpose((0, 1, 3, 2)).reshape(pop.nInd, -1, ploidy)
    qtl_alleles = flat_geno_alleles[:, traits.loci_loc, :]
    qtl_geno = jnp.sum(qtl_alleles, axis=2)

    # --- FIX: Separate the vmap definition from the call ---

    # 1. Create the vectorized function first
    vmapped_calculator = jax.vmap(_calculate_single_gv, in_axes=(0, 0, None))

    # 2. Then, call the new function
    gvs = vmapped_calculator(traits.add_eff, traits.intercept, qtl_geno)
    
    # ---------------------------------------------------------

    return gvs.T


# # NOTE the jit decorator caused a 'missing fun' error, but using the partial function..abs

# Clarity for the Compiler: Instead of asking jax.jit to figure out which argument should be static (via static_argnums), we create a new function that doesn't even have a ploidy argument. We use functools.partial to create _set_pheno_internal with the value of ploidy already "baked in".

# Simplified Tracing: The function that jax.jit sees now only contains arguments that will be traced as JAX arrays (key, pop, traits, etc.). The Python integer ploidy has been resolved before compilation begins. This avoids the internal confusion that was causing the TypeError.
# This function remains the same, but will NOT be jitted directly
def _set_pheno_internal(
    key: jax.random.PRNGKey,
    pop: Population,
    traits: TraitCollection,
    ploidy: int,  # ploidy is now a regular argument
    h2: Float[Array, "nTraits"],
    cor_e: Optional[Float[Array, "nTraits nTraits"]] = None,
) -> Population:
    """
    Internal, non-JITted function to set phenotypes.
    """
    n_traits = traits.n_traits
    if cor_e is None:
        cor_e = jnp.identity(n_traits)

    gvs = _calculate_gvs_vectorized(pop, traits, ploidy)

    var_g = jnp.var(gvs, axis=0)
    var_e = (var_g / h2) - var_g
    cov_e = jnp.diag(jnp.sqrt(var_e)) @ cor_e @ jnp.diag(jnp.sqrt(var_e))
    environmental_noise = jax.random.multivariate_normal(
        key, jnp.zeros(n_traits), cov_e, (pop.nInd,)
    )

    pheno = gvs + environmental_noise

    return pop.replace(pheno=pheno)

# This is the new public-facing, JIT-compatible function
def set_pheno(
    key: jax.random.PRNGKey,
    pop: Population,
    traits: TraitCollection,
    ploidy: int,
    h2: Float[Array, "nTraits"],
    cor_e: Optional[Float[Array, "nTraits nTraits"]] = None,
) -> Population:
    """
    JIT-compatible wrapper to set phenotypes.

    The `ploidy` argument is handled by creating a partially applied
    function that is then JIT-compiled.
    """
    # 1. Create a version of the internal function with `ploidy` "baked in"
    jitted_calculator = jax.jit(
        partial(_set_pheno_internal, ploidy=ploidy)
    )

    # 2. Call the new jitted function without the static argument
    return jitted_calculator(key=key, pop=pop, traits=traits, h2=h2, cor_e=cor_e)

