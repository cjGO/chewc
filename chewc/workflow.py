# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/workflow.ipynb.

# %% auto 0
__all__ = ['config', 'key', 'founder_key', 'founder_pop', 'genetic_map', 'sp', 'state_key', 'initial_state']

# %% ../nbs/workflow.ipynb 3
import jax
from .config import SimConfig
from .structs import SimParam
from .popgen import quick_haplo
from .state import init_state_from_founders
import jax.numpy as jnp


# 1. Define static simulation configuration
config = SimConfig(
    n_chr=10,
    ploidy=2,
    max_pop_size=1000,
    n_loci_per_chr=100,
    n_generations=50,
    n_select=50,
    population_size=101  # invalid value, not multiple
)

# 2. Create a master random key
key = jax.random.PRNGKey(42)
key, founder_key = jax.random.split(key)

# 3. Generate the founder population (runs on host)
founder_pop, genetic_map = quick_haplo(
    key=founder_key,
    n_ind=100,
    n_chr=config.n_chr,
    n_loci_per_chr=config.n_loci_per_chr,
    max_pop_size=config.max_pop_size,
    ploidy=config.ploidy
)

# 4. Define simulation parameters (e.g., genetic maps, trait info)
sp = SimParam(
    gen_map=genetic_map,
    ploidy=config.ploidy,
    # traits, var_e, etc. would be defined here
)

# 5. Initialize the dynamic simulation state (the carry for lax.scan)
# This uses your existing `init_state_from_founders` function.
key, state_key = jax.random.split(key)
initial_state = init_state_from_founders(
    key=state_key,
    founder_pop=founder_pop,
    sp=sp,
    config=config
)

print(f"Initial write position: {initial_state.write_pos}")
print(f"Next available ID: {initial_state.next_id}")
print(f"Founder population active: {jnp.sum(initial_state.is_active)}")

# `initial_state` is now ready to be passed to your JIT'd `generation_step`
# within a `lax.scan`.
