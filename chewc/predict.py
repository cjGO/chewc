"""Common operations around the core datastructures for running a sim"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_predict.ipynb.

# %% auto 0
__all__ = ['PredictionResults', 'gblup_predict', 'gblup_multi_trait']

# %% ../nbs/07_predict.ipynb 3
from flax.struct import dataclass as flax_dataclass
import jax.numpy as jnp
from typing import Optional
from .population import Population

# %% ../nbs/07_predict.ipynb 4
"""
GBLUP (Genomic Best Linear Unbiased Prediction) implementation for chewc library.

This module provides functions for genomic prediction using the GBLUP methodology,
which is a standard approach in genomic selection and animal breeding.
"""

from typing import Optional, Dict
import jax
import jax.numpy as jnp
from jax.numpy.linalg import solve, inv, pinv
from flax.struct import dataclass as flax_dataclass

from .population import Population

@flax_dataclass(frozen=True)
class PredictionResults:
    """
    A container for the results of a genomic prediction.
    """
    ids: jnp.ndarray
    ebv: jnp.ndarray
    pev: Optional[jnp.ndarray] = None
    reliability: Optional[jnp.ndarray] = None
    fixed_effects: Optional[jnp.ndarray] = None
    h2_used: Optional[float] = None
    var_components: Optional[Dict] = None


def _gblup_core(
    phenotypes: jnp.ndarray,
    dosages: jnp.ndarray,
    h2: float,
    trait_idx: int = 0,
    regularization: float = 1e-6
) -> tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray, dict]:
    """
    Core GBLUP calculation. Handles both full and missing data cases.
    """
    y = phenotypes[:, trait_idx]
    n_total = dosages.shape[0]

    valid_mask = ~jnp.isnan(y)
    n_valid = jnp.sum(valid_mask).item()

    if n_valid == 0:
        raise ValueError("No valid (non-NaN) phenotypes found for the selected trait.")

    # --- Shared calculations ---
    p = jnp.mean(dosages[valid_mask], axis=0) / 2 # Allele freqs from phenotyped pop
    W_all = dosages - 2 * p
    denom = 2 * jnp.sum(p * (1 - p))
    G_all = (W_all @ W_all.T) / (denom + regularization)

    y_valid = y[valid_mask]
    y_mean = jnp.mean(y_valid)
    y_centered = y_valid - y_mean
    
    var_y = jnp.var(y_valid)
    var_g = h2 * var_y
    var_e = (1 - h2) * var_y

    # --- Case 1: All individuals have phenotypes (no partitioning needed) ---
    if n_valid == n_total:
        G_reg = G_all + jnp.eye(n_total) * regularization
        lambda_val = var_e / (var_g + regularization)
        X = jnp.ones((n_total, 1))
        Z = jnp.eye(n_total)
        G_inv = pinv(G_reg)

        C11 = X.T @ X
        C12 = X.T @ Z
        C22 = Z.T @ Z + G_inv * lambda_val
        LHS = jnp.block([[C11, C12], [C12.T, C22]])
        RHS = jnp.concatenate([X.T @ y_centered, Z.T @ y_centered])
        
        try:
            solutions = solve(LHS, RHS)
            C_inv = inv(LHS)
        except jnp.linalg.LinAlgError:
            solutions = pinv(LHS) @ RHS
            C_inv = pinv(LHS)

        b_hat = solutions[:1]
        ebv_full = solutions[1:]
        
        pev_full = jnp.diag(C_inv[1:, 1:]) * var_e
        reliability_full = jnp.clip(1 - (pev_full / (var_g + regularization)), 0.0, 1.0)
        
    # --- Case 2: Some individuals have missing phenotypes (partitioning required) ---
    else:
        G_11 = G_all[valid_mask][:, valid_mask]
        G_21 = G_all[~valid_mask][:, valid_mask]
        G_22 = G_all[~valid_mask][:, ~valid_mask]
    
        G_11_reg = G_11 + jnp.eye(n_valid) * regularization
        lambda_val = var_e / (var_g + regularization)
        X1 = jnp.ones((n_valid, 1))
        Z1 = jnp.eye(n_valid)
        G_11_inv = pinv(G_11_reg)

        C11 = X1.T @ X1
        C12 = X1.T @ Z1
        C22 = Z1.T @ Z1 + G_11_inv * lambda_val
        LHS = jnp.block([[C11, C12], [C12.T, C22]])
        RHS = jnp.concatenate([X1.T @ y_centered, Z1.T @ y_centered])

        try:
            solutions = solve(LHS, RHS)
            C_inv = inv(LHS)
        except jnp.linalg.LinAlgError:
            solutions = pinv(LHS) @ RHS
            C_inv = pinv(LHS)

        b_hat = solutions[:1]
        u_hat_1 = solutions[1:]
        u_hat_2 = G_21 @ G_11_inv @ u_hat_1
        
        ebv_full = jnp.zeros(n_total).at[valid_mask].set(u_hat_1).at[~valid_mask].set(u_hat_2)
        
        pev_1 = jnp.diag(C_inv[1:, 1:]) * var_e
        rel_1 = jnp.clip(1 - (pev_1 / (var_g + regularization)), 0.0, 1.0)
        
        pev_2 = jnp.diag(G_22 - G_21 @ G_11_inv @ G_21.T) * var_g
        rel_2 = jnp.clip(1 - (pev_2 / (var_g + regularization)), 0.0, 1.0)
        
        pev_full = jnp.zeros(n_total).at[valid_mask].set(pev_1).at[~valid_mask].set(pev_2)
        reliability_full = jnp.zeros(n_total).at[valid_mask].set(rel_1).at[~valid_mask].set(rel_2)

    # --- Shared summary statistics ---
    h2_realized = jnp.var(ebv_full[valid_mask]) / (var_y + 1e-8)
    var_components = {
        'var_genetic': var_g, 'var_error': var_e, 'var_phenotypic': var_y,
        'h2_input': h2, 'h2_realized': h2_realized,
        'intercept': y_mean + b_hat[0], 'n_valid': n_valid
    }
    return ebv_full, pev_full, reliability_full, var_components


def gblup_predict(
    pop: Population,
    h2: float,
    trait_idx: int = 0,
    regularization: float = 1e-6
) -> PredictionResults:
    """
    Predicts breeding values using GBLUP (Genomic Best Linear Unbiased Prediction).
    """
    if not (0 <= h2 <= 1):
        raise ValueError(f"Heritability must be between 0 and 1, got {h2}")
    if pop.pheno.shape[1] <= trait_idx:
        raise IndexError(f"trait_idx {trait_idx} is out of bounds for {pop.pheno.shape[1]} traits")
    if pop.nInd == 0:
        raise ValueError("Population is empty")

    ebv, pev, reliability, var_components = _gblup_core(
        pop.pheno, pop.dosage, h2, trait_idx=trait_idx, regularization=regularization
    )

    return PredictionResults(
        ids=pop.id,
        ebv=ebv.reshape(-1, 1),
        pev=pev,
        reliability=reliability,
        fixed_effects=jnp.array([var_components['intercept']]),
        h2_used=h2,
        var_components=var_components
    )


def gblup_multi_trait(
    pop: Population,
    h2: jnp.ndarray,
    regularization: float = 1e-6
) -> list[PredictionResults]:
    """
    Performs GBLUP prediction for multiple traits independently.
    """
    if h2.ndim == 0:
        h2 = jnp.array([h2])
    if len(h2) != pop.pheno.shape[1]:
        raise ValueError(f"Number of h2 values ({len(h2)}) must match number of traits ({pop.pheno.shape[1]})")

    results = []
    for trait_idx, h2_val in enumerate(h2):
        result = gblup_predict(pop, float(h2_val), trait_idx, regularization)
        results.append(result)

    return results
