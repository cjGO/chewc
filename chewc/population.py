"""Data Structures for Population"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_population.ipynb.

# %% auto 0
__all__ = ['Population', 'PaddedPopulation', 'to_padded', 'combine_padded', 'quick_haplo', 'combine_populations',
           'subset_population', 'msprime_pop']

# %% ../nbs/01_population.ipynb 4
from dataclasses import field
from typing import List, Optional, Dict, Callable, Any

import jax
import jax.numpy as jnp

from .sp import SimParam
from typing import Tuple
from numpy.random import default_rng
import msprime
import tskit
import numpy as np
import random
from collections import defaultdict
from flax.struct import dataclass as flax_dataclass, field

#testing
import jax
import jax.numpy as jnp
from fastcore.test import test_eq, test_ne

# %% ../nbs/01_population.ipynb 5
@flax_dataclass(frozen=True) # Make the class immutable, a JAX best practice
class Population:
    """
    A container for all data related to a population of individuals, designed
    for JAX-based genetic simulations.

    This structure is immutable. All operations that modify a population should
    return a new Population object.

    Attributes:
        geno (jnp.ndarray): A 4D array representing the genotypes of the population.
            Shape: `(nInd, nChr, ploidy, nLoci)`. dtype: `jnp.uint8`.
        idb (jnp.ndarray): A 4D array representing the founder origins of each allele of the population.
            Shape: `(nInd, nChr, ploidy, nLoci)`. dtype: `jnp.uint8`.        id (jnp.ndarray): The primary, user-facing identifier for each individual.
            These IDs may not be contiguous or sorted. Shape: `(nInd,)`.
        iid (jnp.ndarray): The internal, zero-indexed, contiguous identifier.
            Crucial for robust indexing in JAX operations. Shape: `(nInd,)`.
        mother (jnp.ndarray): Array of internal IDs (`iid`) for the mother of each
            individual. A value of -1 indicates no known mother. Shape: `(nInd,)`.
        father (jnp.ndarray): Array of internal IDs (`iid`) for the father of each
            individual. A value of -1 indicates no known father. Shape: `(nInd,)`.
        sex (jnp.ndarray): The sex of each individual, represented numerically
            (e.g., 0 for male, 1 for female). dtype: `jnp.int8`. Shape: `(nInd,)`.
        gen (jnp.ndarray): The generation each individual is in, represented numerically
             dtype: `jnp.int8`. Shape: `(nInd,)`.

        pheno (jnp.ndarray): The phenotypic values for each individual.
            Shape: `(nInd, nTraits)`.
        fixEff (jnp.ndarray): The value of a fixed effect for each individual,
            often used as an intercept in genomic selection models. Shape: `(nInd,)`.
        
        bv (Optional[jnp.ndarray]): The true breeding values (additive genetic effects)
            for each individual. Shape: `(nInd, nTraits)`.
        dd (Optional[jnp.ndarray]): The true dominance deviations for each individual.
            Shape: `(nInd, nTraits)`.
        aa (Optional[jnp.ndarray]): The true additive-by-additive epistatic deviations
            for each individual. Shape: `(nInd, nTraits)`.

        ebv (Optional[jnp.ndarray]): The estimated breeding values for each
            individual. Shape: `(nInd, nTraits)`.
        gxe (Optional[jnp.ndarray]): Genotype-by-environment interaction effects.
            Shape depends on the specific GxE model.

        misc (Dict): A dictionary for storing miscellaneous, non-JAX-critical
            metadata about individuals. Static.
        miscPop (Dict): A dictionary for storing miscellaneous, non-JAX-critical
            metadata about the entire population. Static.
    """
    # --- Core Genotype Info ---
    geno: jnp.ndarray
    ibd : jnp.ndarray
    
    # --- Pedigree and Identifiers ---
    id: jnp.ndarray
    iid: jnp.ndarray
    mother: jnp.ndarray
    father: jnp.ndarray
    sex: jnp.ndarray
    gen: jnp.ndarray

    # --- Trait and Value Data ---
    pheno: jnp.ndarray
    fixEff: jnp.ndarray
    
    gv: Optional[jnp.ndarray] = None      # Genetic Value (BV + Intercept)
    bv: Optional[jnp.ndarray] = None      # Breeding Value (Additive)
    dd: Optional[jnp.ndarray] = None      # Dominance Deviations
    aa: Optional[jnp.ndarray] = None      # Additive-by-Additive Epistatic Deviations
    
    ebv: Optional[jnp.ndarray] = None
    gxe: Optional[jnp.ndarray] = None

    # --- Metadata ---
    misc: Optional[Dict[str, Any]] = field(default=None, pytree_node=False)
    miscPop: Optional[Dict[str, Any]] = field(default=None, pytree_node=False)

    # def __post_init__(self):
    #     """Validates the consistency of the population data after initialization."""
    #     # --- START: THE ONLY CHANGE NEEDED IN THIS FILE ---
    #     # During a JAX trace (jit, vmap, scan), `self.geno` is a Tracer
    #     # object without a concrete shape. This guard bypasses validation
    #     # during tracing by checking for an attribute that only tracers have.
    #     if isinstance(self.geno, Tracer):
    #         return

    #     # --- END: THE ONLY CHANGE NEEDED IN THIS FILE ---

    #     # The rest of your validation code will now only run in eager mode.
    #     n_ind = self.nInd
    #     # Validate pedigree and identifier shapes
    #     assert self.iid.shape[0] == n_ind, f"Internal ID array length ({self.iid.shape[0]}) must match number of individuals ({n_ind})."
    #     assert self.mother.shape[0] == n_ind, f"Mother array length ({self.mother.shape[0]}) must match number of individuals ({n_ind})."
    #     assert self.father.shape[0] == n_ind, f"Father array length ({self.father.shape[0]}) must match number of individuals ({n_ind})."
    #     assert self.sex.shape[0] == n_ind, f"Sex array length ({self.sex.shape[0]}) must match number of individuals ({n_ind})."
        
    #     # Validate trait-related array shapes
    #     assert self.pheno.shape[0] == n_ind, f"Phenotype (pheno) array length ({self.pheno.shape[0]}) must match number of individuals ({n_ind})."
    #     assert self.fixEff.shape[0] == n_ind, f"Fixed effect (fixEff) array length ({self.fixEff.shape[0]}) must match number of individuals ({n_ind})."
        
    #     # Validate optional genetic value components
    #     if self.bv is not None:
    #         assert self.bv.shape[0] == n_ind, f"Breeding value (bv) array length ({self.bv.shape[0]}) must match number of individuals ({n_ind})."
    #     if self.dd is not None:
    #         assert self.dd.shape[0] == n_ind, f"Dominance deviation (dd) array length ({self.dd.shape[0]}) must match number of individuals ({n_ind})."
    #     if self.aa is not None:
    #         assert self.aa.shape[0] == n_ind, f"Epistatic deviation (aa) array length ({self.aa.shape[0]}) must match number of individuals ({n_ind})."
    #     if self.ebv is not None:
    #         assert self.ebv.shape[0] == n_ind, f"EBV array length ({self.ebv.shape[0]}) must match number of individuals ({n_ind})."

    @property
    def nInd(self) -> int:
        """Returns the number of individuals in the population."""
        return self.geno.shape[0]
    
    @property
    def nChr(self) -> int:
        """Returns the number of chromosomes in the population."""
        return self.geno.shape[1]

    @property
    def nTraits(self) -> int:
        """Returns the number of traits, inferred from the breeding value (bv) shape."""
        if self.bv is None or self.bv.ndim <= 1:
            return 0
        return self.bv.shape[1]
    
    @property
    def haplo_matrix(self) -> jnp.ndarray:
        """ returns a haplotype matrix of shape (n_ind*ploidy, n_chr*n_markers)"""
        return self.geno.transpose(0, 2, 1, 3).reshape(self.geno.shape[0] * self.geno.shape[2], -1)

    @property
    def dosage(self) -> jnp.ndarray:
        """
        Calculates the dosage of alternate alleles for each individual.
        """
        dosage_per_chr = jnp.sum(self.geno, axis=2)
        return dosage_per_chr.reshape(self.nInd, -1)
    
    def plot_maf(self, genetic_map=None, maf_threshold=None):
        """
        Plot MAF distribution as a quick sanity check for the population.
        """
        import matplotlib.pyplot as plt
        
        maf_values = []
        
        # Calculate MAF for each marker
        for chr_idx in range(self.nChr):
            for snp_idx in range(self.geno.shape[3]):
                if genetic_map is not None and jnp.isnan(genetic_map[chr_idx, snp_idx]):
                    continue
                
                marker_genotypes = self.geno[:, chr_idx, :, snp_idx]
                if jnp.any(jnp.isnan(marker_genotypes)):
                    continue
                
                allele_freq = float(jnp.mean(marker_genotypes))
                maf = min(allele_freq, 1 - allele_freq)
                maf_values.append(maf)
        
        if not maf_values:
            print("No valid markers found!")
            return
        
        plt.figure(figsize=(8, 5))
        plt.hist(maf_values, bins=50, alpha=0.7, edgecolor='black')
        plt.xlabel('Minor Allele Frequency (MAF)')
        plt.ylabel('Number of Markers')
        plt.title('MAF Distribution')
        
        mean_maf = jnp.mean(jnp.array(maf_values))
        plt.axvline(mean_maf, color='red', linestyle='--', label=f'Mean: {mean_maf:.3f}')
        
        if maf_threshold is not None:
            plt.axvline(maf_threshold, color='green', linestyle=':', 
                        label=f'Threshold: {maf_threshold}')
        
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()
        
        fixed = sum(1 for maf in maf_values if maf == 0)
        print(f"Markers: {len(maf_values)} | Fixed: {fixed} | Mean MAF: {mean_maf:.3f}")

    def __repr__(self) -> str:
        """Provides a concise representation of the Population object."""
        return (f"Population(nInd={self.nInd}, nTraits={self.nTraits}, "
                f"has_ebv={'Yes' if self.ebv is not None else 'No'})")


# %% ../nbs/01_population.ipynb 6
from typing import List, Optional, Dict, Any
import jax
import jax.numpy as jnp
from flax.struct import dataclass as flax_dataclass, field

#| export
@flax_dataclass(frozen=True)
class PaddedPopulation:
    """
    A container for a population with padded, static-sized arrays
    for use with `jax.vmap` and `jax.lax.scan`.

    This structure is immutable and designed for JIT-compilation. All
    operations must return a new PaddedPopulation object. The arrays
    have a fixed `max_size`, and the `is_active` mask tracks which
    individuals are valid.

    Attributes:
        max_size (int): The static size of the arrays, representing the
            maximum number of individuals the population can hold.
        n_ind (int): The current number of *active* individuals.
        is_active (jnp.ndarray): A boolean mask of shape `(max_size,)`
            indicating which individuals are active.

        geno (jnp.ndarray): Padded genotypes. Shape: `(max_size, nChr, ploidy, nLoci)`.
        ibd (jnp.ndarray): Padded IBD information. Shape: `(max_size, nChr, ploidy, nLoci)`.
        id (jnp.ndarray): Padded primary IDs. Shape: `(max_size,)`.
        iid (jnp.ndarray): Padded internal IDs. Shape: `(max_size,)`.
        mother (jnp.ndarray): Padded mother IDs. Shape: `(max_size,)`.
        father (jnp.ndarray): Padded father IDs. Shape: `(max_size,)`.
        sex (jnp.ndarray): Padded sex information. Shape: `(max_size,)`.
        gen (jnp.ndarray): Padded generation numbers. Shape: `(max_size,)`.
        pheno (jnp.ndarray): Padded phenotypic values. Shape: `(max_size, nTraits)`.
        fixEff (jnp.ndarray): Padded fixed effect values. Shape: `(max_size,)`.
        
        gv (Optional[jnp.ndarray]): Padded genetic values. Shape: `(max_size, nTraits)`.
        bv (Optional[jnp.ndarray]): Padded breeding values. Shape: `(max_size, nTraits)`.
        dd (Optional[jnp.ndarray]): Padded dominance deviations. Shape: `(max_size, nTraits)`.
        aa (Optional[jnp.ndarray]): Padded epistatic deviations. Shape: `(max_size, nTraits)`.
        ebv (Optional[jnp.ndarray]): Padded estimated breeding values. Shape: `(max_size, nTraits)`.
        gxe (Optional[jnp.ndarray]): Padded GxE effects. Shape: `(max_size, ...)`.

        misc (Dict): Static, non-JAX metadata about individuals.
        miscPop (Dict): Static, non-JAX metadata about the population.
    """
    # --- JAX-native additions for static shapes ---
    max_size: int = field(pytree_node=False)
    n_ind: int = field(pytree_node=False)
    is_active: jnp.ndarray

    # --- Core Genotype Info ---
    geno: jnp.ndarray
    ibd: jnp.ndarray

    # --- Pedigree and Identifiers ---
    id: jnp.ndarray
    iid: jnp.ndarray
    mother: jnp.ndarray
    father: jnp.ndarray
    sex: jnp.ndarray
    gen: jnp.ndarray

    # --- Trait and Value Data ---
    pheno: jnp.ndarray
    fixEff: jnp.ndarray

    gv: Optional[jnp.ndarray] = None
    bv: Optional[jnp.ndarray] = None
    dd: Optional[jnp.ndarray] = None
    aa: Optional[jnp.ndarray] = None

    ebv: Optional[jnp.ndarray] = None
    gxe: Optional[jnp.ndarray] = None

    # --- Metadata ---
    misc: Optional[Dict[str, Any]] = field(default=None, pytree_node=False)
    miscPop: Optional[Dict[str, Any]] = field(default=None, pytree_node=False)

    @property
    def nInd(self) -> int:
        """Returns the number of *active* individuals in the population."""
        return self.n_ind

    @property
    def nChr(self) -> int:
        """Returns the number of chromosomes, a static property."""
        return self.geno.shape[1]

    @property
    def nTraits(self) -> int:
        """Returns the number of traits, inferred from the breeding value shape."""
        if self.bv is None or self.bv.ndim <= 1:
            return 0
        return self.bv.shape[1]

    @property
    def haplo_matrix(self) -> jnp.ndarray:
        """
        Returns a haplotype matrix of shape `(n_active_ind * ploidy, n_chr * n_markers)`
        containing only the active individuals.
        Note: This returns a dynamically sized array and is not suitable for use
              inside a JIT-compiled function.
        """
        active_geno = self.geno[:self.n_ind]
        return active_geno.transpose(0, 2, 1, 3).reshape(self.n_ind * active_geno.shape[2], -1)

    @property
    def dosage(self) -> jnp.ndarray:
        """
        Calculates the dosage of alternate alleles for all individuals,
        returning a padded array of shape `(max_size, n_markers)`.
        Dosage for inactive individuals is masked to zero.
        """
        # Calculate dosage for the entire padded array
        full_dosage_per_chr = jnp.sum(self.geno, axis=2)
        full_dosage = full_dosage_per_chr.reshape(self.max_size, -1)
        
        # Apply mask to zero out inactive individuals. The mask needs to be
        # broadcast to match the shape of the dosage array.
        return jnp.where(self.is_active[:, None], full_dosage, 0)

    def __repr__(self) -> str:
        """Provides a concise representation of the PaddedPopulation object."""
        return (f"PaddedPopulation(nInd={self.nInd}, max_size={self.max_size}, "
                f"nTraits={self.nTraits}, has_ebv={'Yes' if self.ebv is not None else 'No'})")

# %% ../nbs/01_population.ipynb 7
import jax.numpy as jnp
from typing import Optional, Dict, Any

# Assume Population and PaddedPopulation dataclasses are defined as in previous steps.
# from .population import Population, PaddedPopulation 

def to_padded(pop: Population, max_size: int) -> PaddedPopulation:
    """
    Converts a dynamic Population object to a static, padded one for JAX transformations.

    This function takes a standard Population object and pads all its array attributes
    to a specified `max_size`, creating a `PaddedPopulation` instance that is compatible
    with `jit`, `vmap`, and `scan`.

    Args:
        pop: The dynamically-sized `Population` object to convert.
        max_size: The target static size for the arrays. This must be greater than
                  or equal to the current number of individuals in the population.

    Returns:
        A new `PaddedPopulation` object with all arrays padded to `max_size`.

    Raises:
        ValueError: If the current population size `pop.nInd` is greater than `max_size`.
    """
    current_n_ind = pop.nInd
    if current_n_ind > max_size:
        raise ValueError(f"Population size ({current_n_ind}) cannot exceed max_size ({max_size}).")

    def _pad(arr: Optional[jnp.ndarray], pad_value: Any) -> Optional[jnp.ndarray]:
        """A helper function to pad a single array to the `max_size`."""
        if arr is None:
            return None
        
        # Define the padding width. We only pad along the first (individual) axis.
        # The format is ((before_axis_0, after_axis_0), (before_axis_1, after_axis_1), ...)
        pad_shape = ((0, max_size - current_n_ind),) + ((0, 0),) * (arr.ndim - 1)
        
        return jnp.pad(arr, pad_shape, 'constant', constant_values=pad_value)

    return PaddedPopulation(
        # Set the new attributes for the padded structure
        max_size=max_size,
        n_ind=current_n_ind,
        is_active=jnp.arange(max_size) < current_n_ind,

        # --- Pad all array fields with appropriate values ---
        
        # Core Genotype Info (padded with 0)
        geno=_pad(pop.geno, 0),
        ibd=_pad(pop.ibd, 0),
        
        # Pedigree and Identifiers (padded with -1)
        id=_pad(pop.id, -1),
        iid=_pad(pop.iid, -1),
        mother=_pad(pop.mother, -1),
        father=_pad(pop.father, -1),
        sex=_pad(pop.sex, -1),
        gen=_pad(pop.gen, -1),

        # Trait and Value Data (padded with NaN for floats)
        pheno=_pad(pop.pheno, jnp.nan),
        fixEff=_pad(pop.fixEff, jnp.nan),
        
        gv=_pad(pop.gv, jnp.nan),
        bv=_pad(pop.bv, jnp.nan),
        dd=_pad(pop.dd, jnp.nan),
        aa=_pad(pop.aa, jnp.nan),
        
        ebv=_pad(pop.ebv, jnp.nan),
        gxe=_pad(pop.gxe, jnp.nan),

        # --- Carry over non-JAX metadata ---
        misc=pop.misc,
        miscPop=pop.miscPop
    )


# (This would ideally go into a new file like `chewc/padded/combine.py`)

import jax
import jax.numpy as jnp
from jax import lax
from .population import Population, PaddedPopulation

def combine_padded(
    current_pop: PaddedPopulation,
    progeny_pop: Population
) -> PaddedPopulation:
    """
    'Combines' a new dynamic population into the next empty slots of a padded one.

    This function is a JAX-compatible way to add individuals to the population
    without changing array shapes. It uses `dynamic_update_slice` to functionally
    "insert" the progeny data at the correct offset.

    Args:
        current_pop: The main PaddedPopulation for the simulation.
        progeny_pop: A standard (small, dynamic) Population object of new progeny.

    Returns:
        An updated PaddedPopulation with the new individuals included.
    """
    n_current = current_pop.n_ind
    n_progeny = progeny_pop.nInd

    # Ensure we don't overflow the pre-allocated arrays
    if n_current + n_progeny > current_pop.max_size:
        raise ValueError("Cannot combine; population exceeds max_size")

    # This is a generic way to update any array in the population structure
    def _update_array(padded_arr, new_arr):
        if padded_arr is None or new_arr is None:
            return padded_arr
        # The start indices are `n_current` for the first axis and 0 for all others
        start_indices = [n_current] + [0] * (new_arr.ndim - 1)
        return lax.dynamic_update_slice(padded_arr, new_arr, start_indices)

    # Use a tree_map to apply the update function to every array in the pytree
    new_pop_pytree = jax.tree_util.tree_map(
        _update_array,
        current_pop,
        progeny_pop
    )

    # Update the count of active individuals and the activity mask
    new_n_ind = n_current + n_progeny
    new_is_active = jnp.arange(current_pop.max_size) < new_n_ind

    return new_pop_pytree.replace(
        n_ind=new_n_ind,
        is_active=new_is_active
    )

# %% ../nbs/01_population.ipynb 8
from typing import Tuple
import jax
import jax.numpy as jnp
# Make sure your updated Population class is imported
# from .population import Population



def quick_haplo(
    key: jax.random.PRNGKey, 
    n_ind: int, 
    n_chr: int, 
    n_loci_per_chr: int, 
    ploidy: int = 2, 
    inbred: bool = False,
    chr_len_cm: float = 100.0
) -> Tuple[Population, jnp.ndarray]:
    """
    Creates a new population with random haplotypes and a uniform genetic map.

    This function is a self-contained founder population generator, analogous to
    AlphaSimR's `quickHaplo`. It no longer depends on a SimParam object.
    Instead, it returns both the Population and the genetic map needed to
    construct a SimParam object later.

    Args:
        key: A JAX random key for reproducibility.
        n_ind: Number of individuals to create.
        n_chr: Number of chromosomes.
        n_loci_per_chr: Number of loci on each chromosome.
        ploidy: The ploidy level of the individuals (default: 2).
        inbred: If True, individuals will be fully inbred (homozygous).
        chr_len_cm: The length of each chromosome in centiMorgans for the
                    generated uniform genetic map (default: 100.0).

    Returns:
        A tuple containing:
        - A new Population object with random founder individuals.
        - A JAX array representing the genetic map, with shape 
          `(n_chr, n_loci_per_chr)`.
    """
    key, geno_key, sex_key = jax.random.split(key, 3)

    # Generate random haplotypes for all individuals and chromosomes
    # Shape: (nInd, nChr, ploidy, nLoci)
    if inbred:
        # Generate one set of haplotypes and tile it across the ploidy axis
        base_haplotypes = jax.random.randint(geno_key, (n_ind, n_chr, 1, n_loci_per_chr), 0, 2, dtype=jnp.uint8)
        geno = jnp.tile(base_haplotypes, (1, 1, ploidy, 1))
    else:
        # Fully random, outbred individuals
        geno = jax.random.randint(geno_key, (n_ind, n_chr, ploidy, n_loci_per_chr), 0, 2, dtype=jnp.uint8)

    # --- Create Pedigree and IDs using JAX arrays ---
    ids = jnp.arange(n_ind)
    sex_array = jax.random.choice(sex_key, jnp.array([0, 1], dtype=jnp.int8), (n_ind,))

    # --- Generate a uniform genetic map ---
    # Each chromosome has loci evenly spaced from 0 to chr_len_cm
    loci_pos = jnp.linspace(0., chr_len_cm, n_loci_per_chr)
    genetic_map = jnp.tile(loci_pos, (n_chr, 1))

    # --- Create unique founder IBD identifiers ---
    # Each allele (at each locus) needs a unique founder ID
    n_founder_alleles = n_ind * n_chr * ploidy * n_loci_per_chr
    founder_ids = jnp.arange(n_founder_alleles, dtype=jnp.uint32)
    ibd = founder_ids.reshape(n_ind, n_chr, ploidy, n_loci_per_chr)
    
    # Handle inbred case: if inbred, IBD should reflect that homologous 
    # chromosomes have identical founder origins
    if inbred:
        # For inbred individuals, both haplotypes should have the same founder IDs
        # Use the first haplotype's IDs for all ploidy copies
        base_ibd = ibd[:, :, 0:1, :]  # Shape: (n_ind, n_chr, 1, n_loci_per_chr)
        ibd = jnp.tile(base_ibd, (1, 1, ploidy, 1))

    population = Population(
        geno=geno,
        ibd=ibd,  # Add IBD tracking
        id=ids,
        iid=ids,  # In a new pop, id and iid are the same
        mother=jnp.full(n_ind, -1, dtype=jnp.int32),
        father=jnp.full(n_ind, -1, dtype=jnp.int32),
        sex=sex_array,
        gen=jnp.zeros(n_ind, dtype=jnp.int32),
        pheno=jnp.zeros((n_ind, 0)),
        fixEff=jnp.zeros(n_ind, dtype=jnp.float32), # Default fixed effect of 0
        bv=jnp.zeros((n_ind, 0)),  # No traits by default
        dd=None,
        aa=None,
    )
    
    return population, genetic_map


# %% ../nbs/01_population.ipynb 10
def combine_populations(pop1, pop2, new_id_start=None):
    """Combine two populations into one, handling ID management and all array sizes"""
    if new_id_start is None:
        new_id_start = jnp.max(pop1.id) + 1
    
    # Update pop2 IDs to avoid conflicts
    pop2_new_ids = jnp.arange(new_id_start, new_id_start + pop2.nInd)
    
    # Create combined population with proper array concatenation for ALL fields
    combined_pop = Population(
        geno=jnp.concatenate([pop1.geno, pop2.geno], axis=0),
        ibd=jnp.concatenate([pop1.ibd, pop2.ibd], axis=0),  # ADDED: Handle IBD array
        id=jnp.concatenate([pop1.id, pop2_new_ids]),
        iid=jnp.arange(pop1.nInd + pop2.nInd),  # Reset internal IDs
        mother=jnp.concatenate([pop1.mother, pop2.mother]),
        father=jnp.concatenate([pop1.father, pop2.father]),
        sex=jnp.concatenate([pop1.sex, pop2.sex]),
        gen=jnp.concatenate([pop1.gen, pop2.gen]),
        pheno=jnp.concatenate([pop1.pheno, pop2.pheno]),
        fixEff=jnp.concatenate([pop1.fixEff, pop2.fixEff]),
        bv=jnp.concatenate([pop1.bv, pop2.bv]) if pop1.bv is not None and pop2.bv is not None else None,
        ebv=jnp.concatenate([pop1.ebv, pop2.ebv]) if pop1.ebv is not None and pop2.ebv is not None else None,
        # Handle optional arrays
        dd=jnp.concatenate([pop1.dd, pop2.dd]) if pop1.dd is not None and pop2.dd is not None else None,
        aa=jnp.concatenate([pop1.aa, pop2.aa]) if pop1.aa is not None and pop2.aa is not None else None,
        gv=jnp.concatenate([pop1.gv, pop2.gv]) if pop1.gv is not None and pop2.gv is not None else None,
        gxe=jnp.concatenate([pop1.gxe, pop2.gxe]) if pop1.gxe is not None and pop2.gxe is not None else None
    )
    
    return combined_pop

def subset_population(pop: Population, indices: jnp.ndarray) -> Population:
    """
    Creates a new Population object containing only the individuals specified by indices.

    Args:
        pop: The original Population object.
        indices: A JAX array of integer indices of individuals to select.

    Returns:
        A new Population object with the subset of individuals.
    """
    n_new_ind = indices.shape[0]

    # Use .at[indices].get() or direct indexing to select rows from each array
    # Ensure all arrays are handled, including optional ones
    return Population(
        geno=pop.geno[indices],
        ibd=pop.ibd[indices],  # ADDED: Handle IBD array
        id=pop.id[indices],
        iid=jnp.arange(n_new_ind, dtype=jnp.int32), # New internal IDs are 0-indexed
        mother=pop.mother[indices],
        father=pop.father[indices],
        sex=pop.sex[indices],
        gen=pop.gen[indices],
        pheno=pop.pheno[indices],
        fixEff=pop.fixEff[indices],
        bv=pop.bv[indices] if pop.bv is not None else None,
        dd=pop.dd[indices] if pop.dd is not None else None,
        aa=pop.aa[indices] if pop.aa is not None else None,
        ebv=pop.ebv[indices] if pop.ebv is not None else None,
        gxe=pop.gxe[indices] if pop.gxe is not None else None,
        # misc and miscPop are static and apply to the whole population,
        # so they are carried over as is.
        misc=pop.misc,
        miscPop=pop.miscPop
    )


# %% ../nbs/01_population.ipynb 11
def msprime_pop(
    key: jax.random.PRNGKey,
    n_ind: int,
    n_loci_per_chr: int,
    n_chr: int,
    ploidy: int = 2,
    effective_population_size: int = 10_000,
    mutation_rate: float = 2e-8,
    recombination_rate_per_chr: float = 2e-8,
    maf_threshold: float = 0.1,
    num_simulated_individuals: int = None,
    base_chr_length: int = 1_000_000,
    enforce_founder_maf: bool = True
) -> Tuple[Population, jnp.ndarray]:
    """
    Creates a new founder population using msprime coalescent simulation.

    Generates genotypes and a genetic map based on population genetics principles.
    Updated with improved parameter validation and more reasonable defaults.

    Args:
        key: JAX random key.
        n_ind: Number of founder individuals to generate.
        n_loci_per_chr: Number of SNPs (loci) to select per chromosome.
        n_chr: Number of chromosomes.
        ploidy: The ploidy level of the individuals (default: 2).
        effective_population_size: The effective population size for simulation.
        mutation_rate: The mutation rate for the simulation.
        recombination_rate_per_chr: Recombination rate per chromosome.
        maf_threshold: Minimum allele frequency threshold for SNPs.
        num_simulated_individuals: Number of individuals to simulate initially.
            If None, will be set to max(n_ind * 2, 1000) for better variant diversity.
        base_chr_length: Length of each chromosome in base pairs.
        enforce_founder_maf: If True, ensures MAF threshold is met in the final
            founder population. If False, applies MAF filter to the full simulated
            population (original behavior).

    Returns:
        A tuple containing:
        - A new Population object with random founder individuals.
        - A JAX array representing the genetic map, with shape 
          `(n_chr, n_loci_per_chr)`.

    Raises:
        ValueError: If parameters are invalid or likely to cause memory issues.
    """
    # --- Parameter Validation ---
    if effective_population_size > 100_000:
        raise ValueError(
            f"Effective population size {effective_population_size} is too large and may cause "
            f"memory issues. Consider using values <= 50,000. For very large populations, "
            f"consider using quick_haplo() instead."
        )
    
    if effective_population_size < 10:
        raise ValueError(
            f"Effective population size {effective_population_size} is too small. "
            f"Use values >= 10 for realistic simulations."
        )
    
    # Set num_simulated_individuals dynamically if not provided
    if num_simulated_individuals is None:
        # If enforcing founder MAF, we need more individuals to ensure diversity
        multiplier = 5 if enforce_founder_maf else 2
        num_simulated_individuals = min(max(n_ind * multiplier, 1000), 10_000)
    
    if n_ind > num_simulated_individuals:
        raise ValueError(
            f"Number of founders requested ({n_ind}) cannot exceed the base simulated "
            f"population size ({num_simulated_individuals})."
        )
    
    # Additional warning for founder MAF enforcement
    if enforce_founder_maf and n_ind < 20:
        import warnings
        warnings.warn(
            f"Small founder population size ({n_ind}) with enforce_founder_maf=True "
            f"may result in few usable markers. Consider increasing n_ind or setting "
            f"enforce_founder_maf=False.",
            UserWarning
        )

    # --- Derive Seeds ---
    key, seed_key, sex_key, numpy_seed_key = jax.random.split(key, 4)
    random_seed = int(jnp.sum(seed_key))
    numpy_seed = int(jnp.sum(numpy_seed_key))
    rng = default_rng(numpy_seed)

    # --- Chromosome Lengths ---
    chromosome_lengths = [base_chr_length] * n_chr

    # --- Run msprime Simulation ---
    num_haplotypes = num_simulated_individuals * ploidy

    # Create the recombination map for msprime
    rate_map_positions = [0] + list(np.cumsum(chromosome_lengths))
    rate_map_rates = [recombination_rate_per_chr] * len(chromosome_lengths)
    rate_map = msprime.RateMap(position=rate_map_positions, rate=rate_map_rates)

    try:
        ts = msprime.sim_ancestry(
            samples=num_haplotypes, 
            population_size=effective_population_size,
            recombination_rate=rate_map, 
            random_seed=random_seed
        )
        mts = msprime.sim_mutations(ts, rate=mutation_rate, random_seed=random_seed)
    except Exception as e:
        if "memory" in str(e).lower() or "malloc" in str(e).lower():
            raise RuntimeError(
                f"Memory allocation failed during msprime simulation. This is likely due to "
                f"too large parameter combination. Try reducing effective_population_size "
                f"(current: {effective_population_size}), num_simulated_individuals "
                f"(current: {num_simulated_individuals}), or genome size. "
                f"Original error: {str(e)}"
            ) from e
        else:
            raise RuntimeError(f"msprime simulation failed: {str(e)}") from e

    # --- Sample Founders FIRST ---
    true_num_individuals = mts.num_samples // ploidy
    founder_indices = np.sort(rng.choice(true_num_individuals, n_ind, replace=False))
    
    # --- Data Extraction with Proper MAF Filtering ---
    all_variants = list(mts.variants())
    genetic_map = np.full((n_chr, n_loci_per_chr), np.nan)
    # Only store founder data directly
    founder_haplotype_matrix = np.full((n_ind, n_chr, ploidy, n_loci_per_chr), np.nan)

    for i in range(n_chr):
        chr_start, chr_end, recomb_rate = rate_map.left[i], rate_map.right[i], rate_map.rate[i]

        # Get all biallelic SNPs in this chromosome
        chromosome_snps = [
            var for var in all_variants
            if chr_start <= var.site.position < chr_end and len(var.alleles) == 2
        ]

        if enforce_founder_maf:
            # Apply MAF filter to the FOUNDER population only
            eligible_snps = []
            for var in chromosome_snps:
                # Extract genotypes for founders only
                all_genotypes = var.genotypes.reshape(true_num_individuals, ploidy)
                founder_genotypes = all_genotypes[founder_indices]
                founder_maf = min(np.mean(founder_genotypes), 1 - np.mean(founder_genotypes))
                
                if founder_maf > maf_threshold:
                    eligible_snps.append(var)
        else:
            # Apply MAF filter to the full simulated population (original behavior)
            eligible_snps = [
                var for var in chromosome_snps
                if min(np.mean(var.genotypes), 1 - np.mean(var.genotypes)) > maf_threshold
            ]

        num_found = len(eligible_snps)
        num_to_select = min(num_found, n_loci_per_chr)

        if num_to_select > 0:
            selected_indices = rng.choice(len(eligible_snps), num_to_select, replace=False)
            selected_snps = [eligible_snps[i] for i in selected_indices]
            selected_snps.sort(key=lambda v: v.site.position)

            for snp_idx, snp in enumerate(selected_snps):
                # Extract genotypes for ALL individuals, then subset to founders
                all_genotypes = snp.genotypes.reshape(true_num_individuals, ploidy)
                founder_genotypes = all_genotypes[founder_indices]
                founder_haplotype_matrix[:, i, :, snp_idx] = founder_genotypes

            positions_cm = [(v.site.position - chr_start) * recomb_rate * 100 for v in selected_snps]
            genetic_map[i, :num_to_select] = positions_cm
        elif num_found == 0:
            import warnings
            population_type = "founder" if enforce_founder_maf else "full simulated"
            warnings.warn(
                f"No variants found for chromosome {i} with MAF > {maf_threshold} in the "
                f"{population_type} population. Consider lowering maf_threshold or "
                f"increasing mutation_rate/effective_population_size.",
                UserWarning
            )

    # --- Founder data is already extracted ---
    founder_haplotypes = founder_haplotype_matrix

    # Convert to JAX arrays
    geno = jnp.array(founder_haplotypes, dtype=jnp.uint8)
    gen_map_jax = jnp.array(genetic_map)

    # --- Create IBD tracking for msprime founders ---
    # For msprime-generated founders, create unique IBD identifiers
    # This is a simplified approach - a more sophisticated version would
    # track actual coalescent relationships from the tree sequence
    n_founder_alleles = n_ind * n_chr * ploidy * n_loci_per_chr
    founder_ids = jnp.arange(n_founder_alleles, dtype=jnp.uint32)
    ibd = founder_ids.reshape(n_ind, n_chr, ploidy, n_loci_per_chr)

    # --- Create Pedigree and IDs using JAX arrays ---
    ids = jnp.arange(n_ind)
    sex_array = jax.random.choice(sex_key, jnp.array([0, 1], dtype=jnp.int8), (n_ind,))
    
    pop = Population(
        geno=geno,
        ibd=ibd,  # Include IBD tracking
        id=ids,
        iid=ids,
        mother=jnp.full(n_ind, -1, dtype=jnp.int32),
        father=jnp.full(n_ind, -1, dtype=jnp.int32),
        sex=sex_array,
        gen=jnp.zeros(n_ind, dtype=jnp.int32),
        pheno=jnp.zeros((n_ind, 0)),
        fixEff=jnp.zeros(n_ind, dtype=jnp.float32),
        bv=jnp.zeros((n_ind, 0)),
        miscPop={
            'msprime_params': {
                'effective_population_size': effective_population_size,
                'mutation_rate': mutation_rate,
                'recombination_rate_per_chr': recombination_rate_per_chr,
                'maf_threshold': maf_threshold,
                'num_simulated_individuals': num_simulated_individuals,
                'base_chr_length': base_chr_length,
                'enforce_founder_maf': enforce_founder_maf
            }
        }
    )

    return pop, gen_map_jax

