"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_meiosis.ipynb.

# %% auto 0
__all__ = ['meiosis_for_one_cross']

# %% ../nbs/05_meiosis.ipynb 4
import jax
import jax.numpy as jnp
from jax import lax, vmap
from functools import partial
import matplotlib.pyplot as plt

@partial(jax.jit, static_argnames=("max_crossovers",))
def _sample_chiasmata(key: jax.random.PRNGKey, 
                      map_length: float, 
                      v: float, 
                      max_crossovers: int = 20) -> jnp.ndarray:
    """
    Generates crossover positions along a single chromosome using a Gamma process
    to model interference.
    """
    shape = v
    scale = 1.0 / (2.0 * v)

    def scan_body(carry, _):
        key, last_pos = carry
        key, subkey = jax.random.split(key)
        distance = jax.random.gamma(subkey, shape) * scale
        new_pos = last_pos + distance
        return (key, new_pos), new_pos

    key, initial_key = jax.random.split(key)
    initial_start_pos = jax.random.uniform(initial_key, minval=-10.0, maxval=0.0)
    init_carry = (key, initial_start_pos)
    
    _, crossover_positions = lax.scan(scan_body, init_carry, None, length=max_crossovers)
    
    # --- CORRECTED LOGIC ---
    # A crossover is only valid if it's within the bounds (0, map_length).
    valid_mask = (crossover_positions > 0) & (crossover_positions < map_length)
    valid_crossovers = jnp.where(valid_mask, 
                                 crossover_positions, 
                                 jnp.nan)
    
    return valid_crossovers


# %% ../nbs/05_meiosis.ipynb 6
@partial(jax.jit, static_argnames=("max_crossovers",))
def _create_gamete(key: jax.random.PRNGKey, 
                   parental_haplotypes: jnp.ndarray,
                   gen_map: jnp.ndarray,
                   v_interference: float,
                   max_crossovers: int = 20) -> jnp.ndarray:
    """
    Creates a single recombinant gamete from a parent's two haplotypes.
    """
    key, chiasma_key, hap_key = jax.random.split(key, 3)

    map_length = gen_map[-1]
    
    crossover_positions = _sample_chiasmata(chiasma_key, map_length, 
                                            v_interference, max_crossovers)

    crossover_indices = jnp.searchsorted(gen_map, crossover_positions)

    start_hap = jax.random.choice(hap_key, jnp.array([0, 1], dtype=jnp.uint8))

    n_loci = gen_map.shape[0]
    
    # --- FIX ---
    # Use side='right' to ensure the crossover happens at the correct locus index.
    locus_segments = jnp.searchsorted(crossover_indices, jnp.arange(n_loci), side='right')
    
    haplotype_choice = (start_hap + locus_segments) % 2
    
    new_gamete = jnp.where(haplotype_choice == 0, 
                           parental_haplotypes[0], 
                           parental_haplotypes[1])
    
    return new_gamete


# %% ../nbs/05_meiosis.ipynb 8
# The signature and decorator are changed to be more specific and JIT-friendly.
@partial(jax.jit, static_argnames=("n_chr",))
def meiosis_for_one_cross(key: jax.random.PRNGKey,
                           mother_geno: jnp.ndarray,
                           father_geno: jnp.ndarray,
                           n_chr: int,
                           gen_map: jnp.ndarray,
                           v_interference: float
                          ) -> jnp.ndarray:
    """
    Creates a single diploid progeny from two parents.
    """
    key_mother, key_father = jax.random.split(key)
    
    # vmap now gets its arguments directly
    vmapped_gamete_creator = vmap(
        _create_gamete, 
        in_axes=(0, 0, 0, None)
    )

    mother_gametes = vmapped_gamete_creator(
        jax.random.split(key_mother, n_chr),
        mother_geno,
        gen_map,
        v_interference
    )

    father_gametes = vmapped_gamete_creator(
        jax.random.split(key_father, n_chr),
        father_geno,
        gen_map,
        v_interference
    )

    progeny_geno = jnp.stack([mother_gametes, father_gametes], axis=1)
    
    return progeny_geno
