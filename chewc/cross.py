"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_cross.ipynb.

# %% auto 0
__all__ = ['make_cross']

# %% ../nbs/06_cross.ipynb 3
import jax
from jax import vmap
import jax.numpy as jnp
from functools import partial

# Assuming these imports are correctly set up in your project structure
from .sp import SimParam
from .population import Population
from .meiosis import meiosis_for_one_cross

# %% ../nbs/06_cross.ipynb 4
@partial(jax.jit, static_argnames=("n_chr",))
def _make_cross_geno(
    key: jax.random.PRNGKey,
    mothers_geno: jnp.ndarray,
    fathers_geno: jnp.ndarray,
    mothers_ibd: jnp.ndarray,    # NEW: Mothers' IBD
    fathers_ibd: jnp.ndarray,    # NEW: Fathers' IBD
    n_chr: int,
    gen_map: jnp.ndarray,
    recomb_param_v: float
) -> tuple[jnp.ndarray, jnp.ndarray]:  # Return both geno and IBD
    """
    (Internal JIT-compiled core) Creates progeny genotypes and IBD from parent genotypes and IBD.

    This function contains only JAX-traceable operations, making it ideal for
    `jax.jit`. It takes JAX arrays as input and returns JAX arrays.

    Args:
        key: A JAX random key. A unique key must be provided for each
             batch of crosses.
        mothers_geno: Genotypes of the mothers. Shape: (nCrosses, nChr, ploidy, nLoci).
        fathers_geno: Genotypes of the fathers. Shape: (nCrosses, nChr, ploidy, nLoci).
        mothers_ibd: IBD arrays of the mothers. Shape: (nCrosses, nChr, ploidy, nLoci).
        fathers_ibd: IBD arrays of the fathers. Shape: (nCrosses, nChr, ploidy, nLoci).
        n_chr: The number of chromosomes (static argument).
        gen_map: The genetic map.
        recomb_param_v: The 'v' interference parameter for recombination.

    Returns:
        A tuple of (progeny_geno, progeny_ibd), both with shape (nCrosses, nChr, ploidy, nLoci).
    """
    # Vectorize the single-cross meiosis function to run all crosses in parallel.
    # `in_axes` maps over the first dimension (the "cross" dimension) of the
    # keys and parent data, while broadcasting the static parameters.
    vmapped_cross_creator = vmap(
        meiosis_for_one_cross,
        in_axes=(0, 0, 0, 0, 0, None, None, None)  # Updated for IBD arrays
    )

    n_crosses = mothers_geno.shape[0]
    cross_keys = jax.random.split(key, n_crosses)

    progeny_geno, progeny_ibd = vmapped_cross_creator(
        cross_keys,
        mothers_geno,
        fathers_geno,
        mothers_ibd,  # Pass mothers' IBD
        fathers_ibd,  # Pass fathers' IBD
        n_chr,
        gen_map,
        recomb_param_v
    )
    return progeny_geno, progeny_ibd


def make_cross(
    key: jax.random.PRNGKey,
    pop: Population,
    cross_plan: jnp.ndarray,
    sp: SimParam,
    next_id_start: int
) -> Population:
    """
    (Public-facing) Creates progeny from a planned series of crosses.

    This function handles the "CPU-side" logic: preparing data from the main
    Population object, calling the JIT-compiled core `_make_cross_geno`, and
    then assembling the results into a new Population object with updated metadata.

    Args:
        key: A single JAX random key.
        pop: The parent population.
        cross_plan: A 2D array of shape (nCrosses, 2) with mother/father iids.
        sp: The simulation parameters.
        next_id_start: The starting integer for the new individuals' public IDs.

    Returns:
        A new Population object for the progeny.
    """
    n_crosses = cross_plan.shape[0]
    key_geno, key_sex = jax.random.split(key)

    # 1. Prepare JAX arrays for the JIT-compiled function
    mother_iids = cross_plan[:, 0]
    father_iids = cross_plan[:, 1]
    mothers_geno = pop.geno[mother_iids]
    fathers_geno = pop.geno[father_iids]
    mothers_ibd = pop.ibd[mother_iids]
    fathers_ibd = pop.ibd[father_iids]

    # 2. Call the highly-optimized, JIT-compiled core function
    progeny_geno, progeny_ibd = _make_cross_geno(
        key_geno,
        mothers_geno,
        fathers_geno,
        mothers_ibd,
        fathers_ibd,
        sp.n_chr,
        sp.gen_map,
        sp.recomb_params[0]
    )

    # 3. Handle CPU-side logic: create new metadata and Population object
    new_public_ids = jnp.arange(next_id_start, next_id_start + n_crosses)
    new_iids = jnp.arange(n_crosses)
    mother_public_ids = pop.id[mother_iids]
    father_public_ids = pop.id[father_iids]

    # --- KEY CHANGE HERE ---
    # Infer progeny generation by adding 1 to the parents' generation.
    # We can safely assume all parents are from the same generation in this context.
    parent_gen = pop.gen[mother_iids[0]] # Get generation from the first mother
    progeny_gen = parent_gen + 1
    # ---------------------

    progeny_pop = Population(
        geno=progeny_geno,
        ibd=progeny_ibd,
        id=new_public_ids,
        iid=new_iids,
        mother=mother_public_ids,
        father=father_public_ids,
        sex=jax.random.choice(key_sex, jnp.array([0, 1], dtype=jnp.int8), (n_crosses,)),
        # Assign the calculated generation to all progeny
        gen=jnp.full(n_crosses, progeny_gen, dtype=jnp.int32),
        pheno=jnp.zeros((n_crosses, sp.n_traits)),
        fixEff=jnp.zeros(n_crosses, dtype=jnp.float32),
        bv=jnp.zeros((n_crosses, sp.n_traits))
    )

    return progeny_pop

