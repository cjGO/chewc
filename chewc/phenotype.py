"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_phenotype.ipynb.

# %% auto 0
__all__ = ['set_bv', 'set_pheno', 'set_bv_padded', 'set_pheno_padded']

# %% ../nbs/04_phenotype.ipynb 3
from typing import Optional
from functools import partial

import jax
import jax.numpy as jnp
from jaxtyping import Array, Float


# --- Imports for Testing ---
from fastcore.test import test_eq, test_close, test_fail
import jax
import jax.numpy as jnp

# --- Project-Specific Imports ---
from .population import Population      # <-- Import the Population class
from .trait import TraitCollection       # <-- Import the TraitCollection class


# %% ../nbs/04_phenotype.ipynb 4
# chewc/phenotype.py


@partial(jax.jit, static_argnames=('ploidy',))
def _calculate_gvs(
    pop: Population,
    traits: TraitCollection,
    ploidy: int
) -> tuple[Float[Array, "nInd nTraits"], Float[Array, "nInd nTraits"]]:
    """
    (JIT-compiled) Calculates all genetic values using a single, 
    highly-optimized matrix multiplication. 'ploidy' is a static argument
    because it affects array shapes during compilation.
    """
    # This logic is identical to your _calculate_gvs_vectorized_alternative
    flat_geno_alleles = pop.geno.transpose((0, 1, 3, 2)).reshape(pop.nInd, -1, ploidy)
    qtl_alleles = flat_geno_alleles[:, traits.loci_loc, :]
    qtl_geno = jnp.sum(qtl_alleles, axis=2)
    all_bv = jnp.dot(qtl_geno, traits.add_eff.T)
    all_gvs = all_bv + traits.intercept
    return all_bv, all_gvs



#| export
# In chewc/phenotype.py, alongside set_pheno

def set_bv(
    pop: Population,
    traits: TraitCollection,
    ploidy: int
) -> Population:
    """
    Calculates and sets the true breeding values (bv) and genetic values (gv)
    for a population based on its genotypes and a given trait architecture.
    This function does NOT generate phenotypes or environmental noise.
    """
    # Call the pre-compiled JAX kernel
    bvs, gvs = _calculate_gvs(pop=pop, traits=traits, ploidy=ploidy)
    return pop.replace(bv=bvs, gv=gvs)

def set_pheno(
    key: jax.random.PRNGKey,
    pop: Population,
    traits: TraitCollection,
    ploidy: int,
    h2: Optional[Float[Array, "nTraits"]] = None,
    varE: Optional[Float[Array, "nTraits"]] = None,
    cor_e: Optional[Float[Array, "nTraits nTraits"]] = None,
) -> Population:
    """
    Sets phenotypes for a population based on its genetic values and
    either a specified heritability (h2) or environmental variance (varE).

    Exactly one of `h2` or `varE` must be provided.
    """
    # 1. --- Input Validation (Python Land) ---
    if (h2 is None and varE is None) or (h2 is not None and varE is not None):
        raise ValueError("Exactly one of 'h2' or 'varE' must be provided.")

    if cor_e is None:
        cor_e = jnp.identity(traits.n_traits)

    # 2. --- Core Genetic Calculation ---
    # Call the pre-compiled JAX kernel for calculating genetic values
    bvs, gvs = _calculate_gvs(pop=pop, traits=traits, ploidy=ploidy)

    # 3. --- Determine Environmental Variance (Python Land) ---
    # This logic remains outside the JIT path as it involves data-dependent
    # shape calculations that are fine to run on the CPU.
    if h2 is not None:
        var_g = jnp.var(gvs, axis=0)
        # Add a small epsilon to prevent division by zero for traits with no variance
        var_e = (var_g / (h2 + 1e-8)) - var_g
        var_e = jnp.maximum(0, var_e) # Ensure variance is not negative
    else: # varE is not None
        var_e = varE

    # 4. --- Add Environmental Noise ---
    # Call the pre-compiled JAX kernel for adding noise
    pheno = _add_environmental_noise(key=key, gvs=gvs, var_e=var_e, cor_e=cor_e)

    # 5. --- Update Population ---
    return pop.replace(bv=bvs, gv=gvs, pheno=pheno)


#| export
@jax.jit
def _add_environmental_noise(
    key: jax.random.PRNGKey,
    gvs: Float[Array, "nInd nTraits"],
    var_e: Float[Array, "nTraits"],
    cor_e: Float[Array, "nTraits nTraits"],
) -> Float[Array, "nInd nTraits"]:
    """
    (JIT-compiled) Internal function to generate and add environmental noise.
    """
    n_ind, n_traits = gvs.shape
    # Ensure var_e is non-negative before taking the square root
    safe_var_e = jnp.maximum(var_e, 0.)
    cov_e = jnp.diag(jnp.sqrt(safe_var_e)) @ cor_e @ jnp.diag(jnp.sqrt(safe_var_e))
    environmental_noise = jax.random.multivariate_normal(
        key, jnp.zeros(n_traits), cov_e, (n_ind,)
    )
    return gvs + environmental_noise



# %% ../nbs/04_phenotype.ipynb 5
from typing import Optional
from functools import partial

import jax
import jax.numpy as jnp
from jaxtyping import Array, Float

# Assume these are importable from your project structure
from .population import Population, PaddedPopulation
from .trait import TraitCollection

# =========================================================================
# --- Padded-Aware JIT Kernels ---
# =========================================================================

@partial(jax.jit, static_argnames=('ploidy',))
def _calculate_gvs_padded(
    pop: "PaddedPopulation",
    traits: "TraitCollection",
    ploidy: int
) -> tuple[Float[Array, "max_size nTraits"], Float[Array, "max_size nTraits"]]:
    """
    (JIT-compiled) Calculates genetic values for a PaddedPopulation.

    This version operates on the full padded arrays and masks the output
    for inactive individuals.
    """
    # Reshape using the static `max_size`
    flat_geno_alleles = pop.geno.transpose((0, 1, 3, 2)).reshape(pop.max_size, -1, ploidy)
    
    qtl_alleles = flat_geno_alleles[:, traits.loci_loc, :]
    qtl_geno = jnp.sum(qtl_alleles, axis=2)
    
    # Calculate BVs and GVs for all potential individuals
    all_bv = jnp.dot(qtl_geno, traits.add_eff.T)
    all_gvs = all_bv + traits.intercept
    
    # Mask the results for inactive individuals to ensure they don't affect
    # downstream calculations like variance. We broadcast the 1D is_active
    # mask to the 2D shape of the results.
    active_mask = pop.is_active[:, None]
    
    masked_bv = jnp.where(active_mask, all_bv, 0.0)
    masked_gvs = jnp.where(active_mask, all_gvs, 0.0)

    return masked_bv, masked_gvs

@partial(jax.jit, static_argnames=('n_traits',))
def _add_environmental_noise_padded(
    key: jax.random.PRNGKey,
    gvs: Float[Array, "max_size nTraits"],
    var_e: Float[Array, "nTraits"],
    cor_e: Float[Array, "nTraits nTraits"],
    is_active: jnp.ndarray,
    n_traits: int
) -> Float[Array, "max_size nTraits"]:
    """
    (JIT-compiled) Internal function to add environmental noise to padded GV arrays.
    """
    max_size = gvs.shape[0]
    safe_var_e = jnp.maximum(var_e, 0.)
    cov_e = jnp.diag(jnp.sqrt(safe_var_e)) @ cor_e @ jnp.diag(jnp.sqrt(safe_var_e))
    
    # Generate noise for the entire padded array
    environmental_noise = jax.random.multivariate_normal(
        key, jnp.zeros(n_traits), cov_e, (max_size,)
    )
    
    # Add noise to genetic values
    pheno = gvs + environmental_noise
    
    # Crucially, set the phenotype of inactive individuals to NaN
    return jnp.where(is_active[:, None], pheno, jnp.nan)

# =========================================================================
# --- Public Padded-Aware Functions ---
# =========================================================================

def set_bv_padded(
    pop: "PaddedPopulation",
    traits: "TraitCollection",
    ploidy: int
) -> "PaddedPopulation":
    """
    Calculates and sets the true breeding values (bv) and genetic values (gv)
    for a PaddedPopulation.
    """
    bvs, gvs = _calculate_gvs_padded(pop=pop, traits=traits, ploidy=ploidy)
    return pop.replace(bv=bvs, gv=gvs)


def set_pheno_padded(
    key: jax.random.PRNGKey,
    pop: "PaddedPopulation",
    traits: "TraitCollection",
    ploidy: int,
    h2: Optional[Float[Array, "nTraits"]] = None,
    varE: Optional[Float[Array, "nTraits"]] = None,
    cor_e: Optional[Float[Array, "nTraits nTraits"]] = None,
) -> "PaddedPopulation":
    """
    Sets phenotypes for a PaddedPopulation based on its genetic values and
    either a specified heritability (h2) or environmental variance (varE).

    This version is designed to be JIT-compatible and works with static shapes.
    """
    # 1. --- Input Validation (can remain outside JIT) ---
    if (h2 is None and varE is None) or (h2 is not None and varE is not None):
        raise ValueError("Exactly one of 'h2' or 'varE' must be provided.")

    if cor_e is None:
        cor_e = jnp.identity(traits.n_traits)

    # 2. --- Core Genetic Calculation ---
    bvs, gvs = _calculate_gvs_padded(pop=pop, traits=traits, ploidy=ploidy)

    # 3. --- Determine Environmental Variance ---
    # This logic can be JIT-compiled because we now operate on known shapes
    # and use the `where` argument for masked variance calculation.
    if h2 is not None:
        # Calculate genetic variance *only for active individuals*
        var_g = jnp.var(gvs, where=pop.is_active[:, None], axis=0)
        var_e = (var_g / (h2 + 1e-8)) - var_g
        var_e = jnp.maximum(0, var_e)
    else:
        var_e = varE

    # 4. --- Add Environmental Noise ---
    pheno = _add_environmental_noise_padded(
        key=key,
        gvs=gvs,
        var_e=var_e,
        cor_e=cor_e,
        is_active=pop.is_active,
        n_traits=traits.n_traits
    )

    # 5. --- Update Population ---
    return pop.replace(bv=bvs, gv=gvs, pheno=pheno)
