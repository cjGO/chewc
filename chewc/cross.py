"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_cross.ipynb.

# %% auto 0
__all__ = ['make_cross']

# %% ../nbs/06_cross.ipynb 4
def make_cross(key: jax.random.PRNGKey, 
               pop: Population, 
               cross_plan: jnp.ndarray, 
               sim_param: SimParam) -> Population:
    """
    Creates progeny from a series of planned crosses in a vectorized manner.

    Args:
        key: A single JAX random key for the entire operation.
        pop: The parent population.
        cross_plan: A 2D array of shape (nCrosses, 2) where each row
                    contains the mother and father iid, respectively.
        sim_param: The simulation parameters object.

    Returns:
        A new Population object containing all the generated progeny.
    """
    n_crosses = cross_plan.shape[0]

    # 1. Gather the genotypes of all parents in the plan.
    # The `cross_plan` contains internal IDs (iids), which are perfect for direct indexing.
    mother_iids = cross_plan[:, 0]
    father_iids = cross_plan[:, 1]
    
    mothers_geno = pop.geno[mother_iids] # Shape: (nCrosses, nChr, ploidy, nLoci)
    fathers_geno = pop.geno[father_iids] # Shape: (nCrosses, nChr, ploidy, nLoci)

    # 2. Create a vectorized version of our single-cross function.
    # `in_axes` tells vmap to map over the first axis of the first three arguments
    # (keys, mothers, fathers) and to treat the subsequent arguments as constant.
    vmapped_cross_creator = vmap(
        meiosis_for_one_cross, 
        in_axes=(0, 0, 0, None, None, None)
    )

    # 3. Generate a unique key for each cross.
    cross_keys = jax.random.split(key, n_crosses)
    
    # 4. Execute all crosses in one parallel operation.
    progeny_geno = vmapped_cross_creator(
        cross_keys,
        mothers_geno,
        fathers_geno,
        sim_param.n_chr,
        sim_param.gen_map,
        sim_param.recomb_params[0]
    )
    # The resulting shape is (nCrosses, nChr, ploidy, nLoci), which matches
    # the shape of our population's `geno` attribute.

    # 5. Create the new Population object for the progeny.
    # Note: This part runs on the CPU after the main JAX computation is done.
    # In a real simulation, you would increment last_id from SimParam.
    new_iids = jnp.arange(n_crosses) 
    
    # Get the public-facing IDs from the parent population
    mother_ids = pop.id[mother_iids]
    father_ids = pop.id[father_iids]
    
    # For simplicity, we create new IDs; in the full library, you'd
    # manage this globally from SimParam.
    new_public_ids = jnp.arange(pop.nInd, pop.nInd + n_crosses) 

    progeny_pop = Population(
        geno=progeny_geno,
        id=new_public_ids,
        iid=new_iids, 
        mother=mother_ids,
        father=father_ids,
        sex=jax.random.choice(key, jnp.array([0, 1], dtype=jnp.int8), (n_crosses,)), # Placeholder
        pheno=jnp.zeros((n_crosses, 0)),
        fixEff=jnp.ones(n_crosses),
    )
    
    return progeny_pop
