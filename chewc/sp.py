"""The SimParam class is the cornerstone of a simulation, acting as a global container for parameters that are not specific to any single Population but govern the rules of the entire simulation. Just as the Population class holds the state of individuals, SimParam holds the "genetic laws" of the simulated world, such as trait architecture, genetic maps, and SNP chip definitions."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_simParam.ipynb.

# %% auto 0
__all__ = ['SimParam']

# %% ../nbs/02_simParam.ipynb 3
import jax.numpy as jnp
from flax.struct import dataclass as flax_dataclass
from dataclasses import field
from typing import List, Optional, TYPE_CHECKING

# The TYPE_CHECKING block is still essential for static type analysis.
if TYPE_CHECKING:
    from .population import Population
    from .trait import TraitA, LociMap, TraitCollection

@flax_dataclass(frozen=True)
class SimParam:
    """
    A container for all global simulation parameters.
    """
    # --- Core Genome Structure ---
    gen_map: jnp.ndarray
    centromere: jnp.ndarray
    ploidy: int

    # --- Genetic Architecture ---
    # **THE FIX**: Use strings for the type hints to avoid the NameError at runtime.
    traits: Optional['TraitCollection'] = None
    snp_chips: List['LociMap'] = field(default_factory=list)

    # --- Population State Reference ---
    # This was already correct.
    founderPop: Optional['Population'] = None

    # --- Simulation Control ---
    sexes: str = "no"
    recomb_params: tuple = (2.6, 0.0, 0.0)
    n_threads: int = 1

    # --- Pedigree & History Tracking ---
    track_pedigree: bool = False
    track_recomb: bool = False
    last_id: int = 0
    pedigree: Optional[jnp.ndarray] = None

    # --- Default Phenotyping Parameters ---
    var_e: Optional[jnp.ndarray] = None

    @property
    def n_chr(self) -> int:
        return self.gen_map.shape[0]

    @property
    def n_loci_per_chr(self) -> jnp.ndarray:
        return jnp.full((self.n_chr,), self.gen_map.shape[1])

    @property
    def n_traits(self) -> int:
        """
        This logic is now correct and relies on the fix above.
        """
        if self.traits is None:
            return 0
        return self.traits.n_traits

    def __repr__(self) -> str:
        return (f"SimParam(nChr={self.n_chr}, nTraits={self.n_traits}, "
                f"ploidy={self.ploidy}, sexes='{self.sexes}')")
